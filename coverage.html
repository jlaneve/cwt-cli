
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jlaneve/cwt-cli/internal/cli/attach.go (2.2%)</option>
				
				<option value="file1">github.com/jlaneve/cwt-cli/internal/cli/cleanup.go (10.8%)</option>
				
				<option value="file2">github.com/jlaneve/cwt-cli/internal/cli/delete.go (5.8%)</option>
				
				<option value="file3">github.com/jlaneve/cwt-cli/internal/cli/diff.go (6.9%)</option>
				
				<option value="file4">github.com/jlaneve/cwt-cli/internal/cli/fix_hooks.go (3.1%)</option>
				
				<option value="file5">github.com/jlaneve/cwt-cli/internal/cli/hook.go (13.3%)</option>
				
				<option value="file6">github.com/jlaneve/cwt-cli/internal/cli/list.go (3.0%)</option>
				
				<option value="file7">github.com/jlaneve/cwt-cli/internal/cli/merge.go (7.5%)</option>
				
				<option value="file8">github.com/jlaneve/cwt-cli/internal/cli/new.go (5.9%)</option>
				
				<option value="file9">github.com/jlaneve/cwt-cli/internal/cli/publish.go (6.5%)</option>
				
				<option value="file10">github.com/jlaneve/cwt-cli/internal/cli/root.go (62.5%)</option>
				
				<option value="file11">github.com/jlaneve/cwt-cli/internal/cli/selector.go (0.0%)</option>
				
				<option value="file12">github.com/jlaneve/cwt-cli/internal/cli/status.go (4.1%)</option>
				
				<option value="file13">github.com/jlaneve/cwt-cli/internal/cli/switch.go (2.4%)</option>
				
				<option value="file14">github.com/jlaneve/cwt-cli/internal/cli/tui.go (25.0%)</option>
				
				<option value="file15">github.com/jlaneve/cwt-cli/internal/clients/claude/checker.go (7.0%)</option>
				
				<option value="file16">github.com/jlaneve/cwt-cli/internal/clients/claude/scanner.go (0.0%)</option>
				
				<option value="file17">github.com/jlaneve/cwt-cli/internal/clients/git/checker.go (9.0%)</option>
				
				<option value="file18">github.com/jlaneve/cwt-cli/internal/clients/tmux/checker.go (42.6%)</option>
				
				<option value="file19">github.com/jlaneve/cwt-cli/internal/events/bus.go (100.0%)</option>
				
				<option value="file20">github.com/jlaneve/cwt-cli/internal/operations/cleanup.go (76.5%)</option>
				
				<option value="file21">github.com/jlaneve/cwt-cli/internal/operations/formatting.go (96.9%)</option>
				
				<option value="file22">github.com/jlaneve/cwt-cli/internal/operations/sessions.go (87.1%)</option>
				
				<option value="file23">github.com/jlaneve/cwt-cli/internal/state/manager.go (69.7%)</option>
				
				<option value="file24">github.com/jlaneve/cwt-cli/internal/state/validation.go (97.1%)</option>
				
				<option value="file25">github.com/jlaneve/cwt-cli/internal/tui/commands.go (0.0%)</option>
				
				<option value="file26">github.com/jlaneve/cwt-cli/internal/tui/model.go (1.4%)</option>
				
				<option value="file27">github.com/jlaneve/cwt-cli/internal/tui/tui.go (0.0%)</option>
				
				<option value="file28">github.com/jlaneve/cwt-cli/internal/tui/view.go (0.0%)</option>
				
				<option value="file29">github.com/jlaneve/cwt-cli/internal/types/events.go (100.0%)</option>
				
				<option value="file30">github.com/jlaneve/cwt-cli/internal/types/session_state.go (18.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
        "syscall"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

func newAttachCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "attach [session-name]",
                Short: "Attach to a session's tmux session",
                Long: `Attach to the tmux session for a CWT session.

This is a convenience command that replaces the need to remember
tmux session names (cwt-{session-name}). 

If session-name is not provided, you will be prompted to select
from available sessions.`,
                Aliases: []string{"a"},
                Args:    cobra.MaximumNArgs(1),
                RunE:    runAttachCmd,
        }

        return cmd
}</span>

func runAttachCmd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        // Get sessions
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions found.")
                fmt.Println("Create a new session with: cwt new [session-name]")
                return fmt.Errorf("no sessions available to attach to")
        }</span>

        // Determine which session to attach to
        <span class="cov0" title="0">var sessionToAttach *types.Session

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                // Session name provided
                sessionName := args[0]
                for i := range sessions </span><span class="cov0" title="0">{
                        if sessions[i].Core.Name == sessionName </span><span class="cov0" title="0">{
                                sessionToAttach = &amp;sessions[i]
                                break</span>
                        }
                }

                <span class="cov0" title="0">if sessionToAttach == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("session '%s' not found", sessionName)
                }</span>
        } else<span class="cov0" title="0"> {
                // Interactive selection
                selected, err := promptForAttachSelection(sessions)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sessionToAttach = selected</span>
        }

        // Check if tmux session is alive
        <span class="cov0" title="0">if !sessionToAttach.IsAlive </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Tmux session for '%s' is not running.\n", sessionToAttach.Core.Name)
                fmt.Printf("This might happen if:\n")
                fmt.Printf("  ‚Ä¢ The Claude Code process exited\n")
                fmt.Printf("  ‚Ä¢ The tmux session was manually terminated\n")
                fmt.Printf("  ‚Ä¢ There was a system restart\n\n")

                // Ask user if they want to recreate the session
                fmt.Printf("Do you want to recreate the tmux session? (y/N): ")
                var response string
                fmt.Scanln(&amp;response)

                if strings.ToLower(response) != "y" &amp;&amp; strings.ToLower(response) != "yes" </span><span class="cov0" title="0">{
                        fmt.Println("Session not recreated.")
                        return fmt.Errorf("cannot attach to dead tmux session")
                }</span>

                // Recreate the tmux session with Claude resumption
                <span class="cov0" title="0">if err := recreateSessionWithClaudeResume(sm, sessionToAttach); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to recreate session: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("‚úÖ Session '%s' recreated successfully\n", sessionToAttach.Core.Name)</span>
        }

        // Attach to tmux session
        <span class="cov0" title="0">fmt.Printf("üîó Attaching to session '%s' (tmux: %s)...\n",
                sessionToAttach.Core.Name, sessionToAttach.Core.TmuxSession)

        // Use exec to replace current process with tmux attach
        tmuxPath, err := exec.LookPath("tmux")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tmux not found in PATH: %w", err)
        }</span>

        <span class="cov0" title="0">args = []string{"tmux", "attach-session", "-t", sessionToAttach.Core.TmuxSession}
        err = syscall.Exec(tmuxPath, args, os.Environ())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to exec tmux: %w", err)
        }</span>

        // This point should never be reached if exec succeeds
        <span class="cov0" title="0">return nil</span>
}

func promptForAttachSelection(sessions []types.Session) (*types.Session, error) <span class="cov0" title="0">{
        fmt.Println("Multiple sessions found. Select one to attach to:")

        // Filter to only show alive sessions
        aliveSessions := make([]types.Session, 0)
        deadSessions := make([]types.Session, 0)

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.IsAlive </span><span class="cov0" title="0">{
                        aliveSessions = append(aliveSessions, session)
                }</span> else<span class="cov0" title="0"> {
                        deadSessions = append(deadSessions, session)
                }</span>
        }

        <span class="cov0" title="0">if len(aliveSessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚ùå No active tmux sessions found.")
                if len(deadSessions) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Found %d stale session(s). Run 'cwt cleanup' to remove them.\n", len(deadSessions))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("no active sessions to attach to")</span>
        }

        <span class="cov0" title="0">if len(deadSessions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Found %d stale session(s). Run 'cwt cleanup' to remove them.\n", len(deadSessions))
        }</span>

        // Use interactive selector for alive sessions
        <span class="cov0" title="0">selectedSession, err := SelectSession(aliveSessions, WithTitle("Select a session to attach to:"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to select session: %w", err)
        }</span>

        <span class="cov0" title="0">if selectedSession == nil </span><span class="cov0" title="0">{
                fmt.Println("Cancelled")
                return nil, nil
        }</span>

        <span class="cov0" title="0">return selectedSession, nil</span>
}

// recreateSessionWithClaudeResume recreates a dead tmux session and resumes Claude if possible
func recreateSessionWithClaudeResume(sm *state.Manager, session *types.Session) error <span class="cov0" title="0">{
        // Find Claude executable
        claudeExec := findClaudeExecutable()
        if claudeExec == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("claude executable not found")
        }</span>

        // Check if there's an existing Claude session to resume for this worktree
        <span class="cov0" title="0">var command string
        if existingSessionID, err := sm.GetClaudeChecker().FindSessionID(session.Core.WorktreePath); err == nil &amp;&amp; existingSessionID != "" </span><span class="cov0" title="0">{
                command = fmt.Sprintf("%s -r %s", claudeExec, existingSessionID)
                fmt.Printf("üìã Resuming Claude session %s\n", existingSessionID)
        }</span> else<span class="cov0" title="0"> {
                command = claudeExec
                fmt.Printf("üÜï Starting new Claude session\n")
        }</span>

        // Recreate the tmux session
        <span class="cov0" title="0">tmuxChecker := sm.GetTmuxChecker()
        if err := tmuxChecker.CreateSession(session.Core.TmuxSession, session.Core.WorktreePath, command); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to recreate tmux session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// findClaudeExecutable searches for claude in common installation paths
func findClaudeExecutable() string <span class="cov0" title="0">{
        claudePaths := []string{
                "claude",
                os.ExpandEnv("$HOME/.claude/local/claude"),
                os.ExpandEnv("$HOME/.claude/local/node_modules/.bin/claude"),
                "/usr/local/bin/claude",
        }

        for _, path := range claudePaths </span><span class="cov0" title="0">{
                cmd := exec.Command(path, "--version")
                if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "fmt"

        "github.com/jlaneve/cwt-cli/internal/operations"
        "github.com/spf13/cobra"
)

func newCleanupCmd() *cobra.Command <span class="cov8" title="1">{
        var dryRun bool

        cmd := &amp;cobra.Command{
                Use:   "cleanup",
                Short: "Remove orphaned sessions and resources",
                Long: `Clean up orphaned CWT resources:
- Sessions with dead tmux sessions
- Unused git worktrees
- Stale session metadata

This helps maintain a clean state after crashes or manual tmux session termination.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runCleanupCmd(dryRun)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be cleaned up without actually doing it")

        return cmd</span>
}

func runCleanupCmd(dryRun bool) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        fmt.Println("üîç Scanning for orphaned resources...")

        // Use operations layer for cleanup
        cleanupOps := operations.NewCleanupOperations(sm)
        stats, err := cleanupOps.FindAndCleanupStaleResources(dryRun)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cleanup failed: %w", err)
        }</span>

        // Show what was found
        <span class="cov0" title="0">totalOrphans := stats.StaleSessions + stats.OrphanedTmux + stats.OrphanedWorktrees
        if totalOrphans == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚úÖ No orphaned resources found. Everything looks clean!")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nFound orphaned resources:\n")
        if stats.StaleSessions &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  üìÇ %d stale session(s) with dead tmux\n", stats.StaleSessions)
        }</span>
        <span class="cov0" title="0">if stats.OrphanedTmux &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  üîß %d orphaned tmux session(s)\n", stats.OrphanedTmux)
        }</span>
        <span class="cov0" title="0">if stats.OrphanedWorktrees &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  üå≥ %d orphaned git worktree(s)\n", stats.OrphanedWorktrees)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        if dryRun </span><span class="cov0" title="0">{
                fmt.Println("üîç Dry run mode - no changes made.")
                fmt.Printf("Run 'cwt cleanup' to actually clean up these %d resource(s).\n", totalOrphans)
                return nil
        }</span>

        // Show cleanup results
        <span class="cov0" title="0">fmt.Printf("üßπ Cleanup complete!\n")
        fmt.Printf("  ‚úÖ Cleaned: %d\n", stats.Cleaned)
        if stats.Failed &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  ‚ùå Failed: %d\n", stats.Failed)
                for _, errMsg := range stats.Errors </span><span class="cov0" title="0">{
                        fmt.Printf("    - %s\n", errMsg)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/operations"
        "github.com/jlaneve/cwt-cli/internal/types"
)

func newDeleteCmd() *cobra.Command <span class="cov8" title="1">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "delete [session-name]",
                Short: "Delete a session and clean up its resources",
                Long: `Delete a CWT session, removing:
- Tmux session
- Git worktree
- Session metadata

This operation cannot be undone.`,
                Aliases: []string{"del", "rm"},
                Args:    cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runDeleteCmd(args, force)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        return cmd</span>
}

func runDeleteCmd(args []string, force bool) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        // Create operations layer
        sessionOps := operations.NewSessionOperations(sm)

        // Get sessions
        sessions, err := sessionOps.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions found to delete.")
                return fmt.Errorf("no sessions available to delete")
        }</span>

        // Determine which session to delete
        <span class="cov0" title="0">var sessionToDelete *string
        var sessionID string

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                // Session name provided - use operations layer
                sessionName := args[0]
                session, id, err := sessionOps.FindSessionByName(sessionName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sessionToDelete = &amp;session.Core.Name
                sessionID = id</span>
        } else<span class="cov0" title="0"> {
                // Interactive selection
                sessionName, id, err := promptForSessionSelection(sessions)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sessionToDelete = &amp;sessionName
                sessionID = id</span>
        }

        // Confirm deletion unless forced
        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                if !confirmDeletion(*sessionToDelete) </span><span class="cov0" title="0">{
                        fmt.Println("Deletion cancelled.")
                        return nil
                }</span>
        }

        // Delete session using operations layer
        <span class="cov0" title="0">fmt.Printf("Deleting session '%s'...\n", *sessionToDelete)

        if err := sessionOps.DeleteSession(sessionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete session: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Session '%s' deleted successfully!\n", *sessionToDelete)

        return nil</span>
}

func promptForSessionSelection(sessions []types.Session) (string, string, error) <span class="cov0" title="0">{
        if len(sessions) == 1 </span><span class="cov0" title="0">{
                return sessions[0].Core.Name, sessions[0].Core.ID, nil
        }</span>

        <span class="cov0" title="0">fmt.Println("Multiple sessions found. Select one to delete:")
        for i, session := range sessions </span><span class="cov0" title="0">{
                status := "üî¥ dead"
                if session.IsAlive </span><span class="cov0" title="0">{
                        status = "üü¢ alive"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %d. %s (%s)\n", i+1, session.Core.Name, status)</span>
        }

        <span class="cov0" title="0">reader := bufio.NewReader(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Print("Enter selection (1-" + fmt.Sprintf("%d", len(sessions)) + "): ")
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>

                <span class="cov0" title="0">var selection int
                if _, err := fmt.Sscanf(strings.TrimSpace(input), "%d", &amp;selection); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Invalid input. Please enter a number.")
                        continue</span>
                }

                <span class="cov0" title="0">if selection &lt; 1 || selection &gt; len(sessions) </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid selection. Please enter a number between 1 and %d.\n", len(sessions))
                        continue</span>
                }

                <span class="cov0" title="0">selectedSession := sessions[selection-1]
                return selectedSession.Core.Name, selectedSession.Core.ID, nil</span>
        }
}

func confirmDeletion(sessionName string) bool <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)

        fmt.Printf("Are you sure you want to delete session '%s'? This cannot be undone. (y/N): ", sessionName)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">response := strings.ToLower(strings.TrimSpace(input))
        return response == "y" || response == "yes"</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// newDiffCmd creates the 'cwt diff' command
func newDiffCmd() *cobra.Command <span class="cov8" title="1">{
        var against string
        var web bool
        var stat bool
        var name bool
        var cached bool

        cmd := &amp;cobra.Command{
                Use:   "diff [session-name]",
                Short: "Show detailed diff for session changes",
                Long: `Show comprehensive diff view of changes in a session with rich formatting.

Examples:
  cwt diff my-session               # Show full diff for session
  cwt diff my-session --stat        # Show diff statistics only
  cwt diff my-session --against main # Compare against specific branch
  cwt diff my-session --web          # Open diff in external viewer
  cwt diff my-session --cached       # Show staged changes only
  cwt diff                          # Interactive session selector`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sm, err := createStateManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer sm.Close()

                        if len(args) == 0 </span><span class="cov0" title="0">{
                                return interactiveDiff(sm, against, web, stat, name, cached)
                        }</span>

                        <span class="cov0" title="0">sessionName := args[0]
                        return showSessionDiff(sm, sessionName, against, web, stat, name, cached)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVar(&amp;against, "against", "", "Compare against specific branch (default: base branch)")
        cmd.Flags().BoolVar(&amp;web, "web", false, "Open diff in external viewer")
        cmd.Flags().BoolVar(&amp;stat, "stat", false, "Show diff statistics only")
        cmd.Flags().BoolVar(&amp;name, "name-only", false, "Show only file names")
        cmd.Flags().BoolVar(&amp;cached, "cached", false, "Show staged changes only")

        return cmd</span>
}

// showSessionDiff displays the diff for a specific session
func showSessionDiff(sm *state.Manager, sessionName, against string, web, stat, nameOnly, cached bool) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        // Find the session
        <span class="cov0" title="0">var targetSession *types.Session
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.Core.Name == sessionName </span><span class="cov0" title="0">{
                        targetSession = &amp;session
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetSession == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session '%s' not found", sessionName)
        }</span>

        <span class="cov0" title="0">return renderSessionDiff(*targetSession, against, web, stat, nameOnly, cached)</span>
}

// interactiveDiff provides an interactive session selector for diff
func interactiveDiff(sm *state.Manager, against string, web, stat, nameOnly, cached bool) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions available for diff")
                return nil
        }</span>

        // Use selector with filter for sessions with changes
        <span class="cov0" title="0">selectedSession, err := SelectSession(sessions,
                WithTitle("Select a session to view diff:"),
                WithSessionFilter(func(session types.Session) bool </span><span class="cov0" title="0">{
                        return session.GitStatus.HasChanges
                }</span>))

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to select session: %w", err)
        }</span>

        <span class="cov0" title="0">if selectedSession == nil </span><span class="cov0" title="0">{
                fmt.Println("Cancelled")
                return nil
        }</span>

        <span class="cov0" title="0">return renderSessionDiff(*selectedSession, against, web, stat, nameOnly, cached)</span>
}

// renderSessionDiff renders the diff for a session
func renderSessionDiff(session types.Session, against string, web, stat, nameOnly, cached bool) error <span class="cov0" title="0">{
        // Change to session worktree directory
        originalDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Chdir(originalDir)

        if err := os.Chdir(session.Core.WorktreePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change to worktree directory: %w", err)
        }</span>

        // Determine comparison target
        <span class="cov0" title="0">target := against
        if target == "" </span><span class="cov0" title="0">{
                target = "main" // Default base branch
        }</span>

        // Open in external viewer if requested
        <span class="cov0" title="0">if web </span><span class="cov0" title="0">{
                return openDiffInExternalViewer(target, cached)
        }</span>

        // Show diff header
        <span class="cov0" title="0">fmt.Printf("üìã Diff for session: %s\n", session.Core.Name)
        fmt.Printf("üìÇ Path: %s\n", session.Core.WorktreePath)

        if cached </span><span class="cov0" title="0">{
                fmt.Printf("üîç Comparing: staged changes\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("üîç Comparing: working tree vs %s\n", target)
        }</span>

        <span class="cov0" title="0">fmt.Println(strings.Repeat("=", 70))

        // Show summary stats first
        if err := showDiffStats(target, cached); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to show diff stats: %v\n", err)
        }</span>

        <span class="cov0" title="0">if stat </span><span class="cov0" title="0">{
                return nil // Only show stats
        }</span>

        <span class="cov0" title="0">fmt.Println(strings.Repeat("-", 70))

        // Show file names only if requested
        if nameOnly </span><span class="cov0" title="0">{
                return showDiffFileNames(target, cached)
        }</span>

        // Show full diff with syntax highlighting
        <span class="cov0" title="0">return showFullDiff(target, cached)</span>
}

// showDiffStats shows diff statistics
func showDiffStats(target string, cached bool) error <span class="cov0" title="0">{
        var cmd *exec.Cmd

        if cached </span><span class="cov0" title="0">{
                cmd = exec.Command("git", "diff", "--cached", "--stat")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("git", "diff", target, "--stat")
        }</span>

        <span class="cov0" title="0">output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(output) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("üìä Change Statistics:\n")
                fmt.Print(string(output))
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("üìä No changes found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// showDiffFileNames shows only the names of changed files
func showDiffFileNames(target string, cached bool) error <span class="cov0" title="0">{
        var cmd *exec.Cmd

        if cached </span><span class="cov0" title="0">{
                cmd = exec.Command("git", "diff", "--cached", "--name-status")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("git", "diff", target, "--name-status")
        }</span>

        <span class="cov0" title="0">output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file names: %w", err)
        }</span>

        <span class="cov0" title="0">if len(output) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No files changed")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Println("üìÅ Changed Files:")
        lines := strings.Split(strings.TrimSpace(string(output)), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "\t", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">status := parts[0]
                filename := parts[1]

                icon := getFileStatusIcon(status)
                fmt.Printf("  %s %s %s\n", icon, status, filename)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// showFullDiff shows the complete diff with syntax highlighting
func showFullDiff(target string, cached bool) error <span class="cov0" title="0">{
        var cmd *exec.Cmd

        if cached </span><span class="cov0" title="0">{
                cmd = exec.Command("git", "diff", "--cached", "--color=always")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("git", "diff", target, "--color=always")
        }</span>

        // Try to use a pager if available (less, more, etc.)
        <span class="cov0" title="0">if isInteractiveTerminal() </span><span class="cov0" title="0">{
                if pager := getPager(); pager != "" </span><span class="cov0" title="0">{
                        return runDiffWithPager(cmd, pager)
                }</span>
        }

        // Fallback to direct output
        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to show diff: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// openDiffInExternalViewer opens the diff in an external application
func openDiffInExternalViewer(target string, cached bool) error <span class="cov0" title="0">{
        // Try different diff viewers in order of preference
        viewers := []string{
                "code --diff", // VSCode
                "subl --wait", // Sublime Text
                "mate -w",     // TextMate
                "vim -d",      // Vim
        }

        for _, viewer := range viewers </span><span class="cov0" title="0">{
                if cmd := strings.Fields(viewer); len(cmd) &gt; 0 </span><span class="cov0" title="0">{
                        if _, err := exec.LookPath(cmd[0]); err == nil </span><span class="cov0" title="0">{
                                return openWithViewer(viewer, target, cached)
                        }</span>
                }
        }

        // Fallback to system default
        <span class="cov0" title="0">return openWithSystemDefault(target, cached)</span>
}

// openWithViewer opens diff with a specific viewer
func openWithViewer(viewer, target string, cached bool) error <span class="cov0" title="0">{
        // For now, just show the diff in terminal with a message
        fmt.Printf("üîß External viewer integration not yet implemented\n")
        fmt.Printf("üìã Preferred viewer: %s\n", viewer)
        fmt.Println("üìã Falling back to terminal diff:")
        fmt.Println(strings.Repeat("-", 50))

        return showFullDiff(target, cached)
}</span>

// openWithSystemDefault opens diff with system default application
func openWithSystemDefault(target string, cached bool) error <span class="cov0" title="0">{
        fmt.Println("üîß System default diff viewer not yet implemented")
        fmt.Println("üìã Falling back to terminal diff:")
        fmt.Println(strings.Repeat("-", 50))

        return showFullDiff(target, cached)
}</span>

// Helper functions

func getFileStatusIcon(status string) string <span class="cov0" title="0">{
        switch status </span>{
        case "A":<span class="cov0" title="0">
                return "‚ûï"</span>
        case "M":<span class="cov0" title="0">
                return "üìù"</span>
        case "D":<span class="cov0" title="0">
                return "‚ûñ"</span>
        case "R":<span class="cov0" title="0">
                return "üìã"</span>
        case "C":<span class="cov0" title="0">
                return "üìÑ"</span>
        default:<span class="cov0" title="0">
                return "‚ùì"</span>
        }
}

func isInteractiveTerminal() bool <span class="cov0" title="0">{
        // Simple check for interactive terminal
        if os.Getenv("TERM") == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if stdout is a terminal
        <span class="cov0" title="0">if stat, err := os.Stdout.Stat(); err == nil </span><span class="cov0" title="0">{
                return (stat.Mode() &amp; os.ModeCharDevice) != 0
        }</span>

        <span class="cov0" title="0">return false</span>
}

func getPager() string <span class="cov0" title="0">{
        // Check environment variables for pager preference
        if pager := os.Getenv("GIT_PAGER"); pager != "" </span><span class="cov0" title="0">{
                return pager
        }</span>

        <span class="cov0" title="0">if pager := os.Getenv("PAGER"); pager != "" </span><span class="cov0" title="0">{
                return pager
        }</span>

        // Try common pagers
        <span class="cov0" title="0">pagers := []string{"less", "more", "cat"}
        for _, pager := range pagers </span><span class="cov0" title="0">{
                if _, err := exec.LookPath(pager); err == nil </span><span class="cov0" title="0">{
                        if pager == "less" </span><span class="cov0" title="0">{
                                return "less -R" // Enable color support
                        }</span>
                        <span class="cov0" title="0">return pager</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

func runDiffWithPager(cmd *exec.Cmd, pager string) error <span class="cov0" title="0">{
        // Create a pipe from git diff to pager
        pagerCmd := exec.Command("sh", "-c", pager)

        pipe, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pipe: %w", err)
        }</span>

        <span class="cov0" title="0">pagerCmd.Stdin = pipe
        pagerCmd.Stdout = os.Stdout
        pagerCmd.Stderr = os.Stderr

        if err := pagerCmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start pager: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start git diff: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                pipe.Close()
                return fmt.Errorf("git diff failed: %w", err)
        }</span>

        <span class="cov0" title="0">pipe.Close()

        if err := pagerCmd.Wait(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pager failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cli

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
)

func newFixHooksCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "fix-hooks",
                Short: "Fix broken hook paths in existing sessions",
                Long: `Auto-detect and fix broken hook paths in Claude settings.json files.

This command scans all existing sessions and updates any invalid executable
paths in their Claude hook configurations. This is useful when:
- Sessions were created with 'go run' and have temp executable paths
- The cwt binary was moved or renamed
- Hook paths are pointing to non-existent executables`,
                RunE: runFixHooksCmd,
        }

        return cmd
}</span>

func runFixHooksCmd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions found.")
                return nil
        }</span>

        // Get the correct cwt executable path
        <span class="cov0" title="0">correctPath := getCwtExecutablePath()

        fixed := 0
        for _, session := range sessions </span><span class="cov0" title="0">{
                settingsPath := filepath.Join(session.Core.WorktreePath, "settings.json")

                if updated, err := fixSettingsFile(settingsPath, session.Core.ID, correctPath); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Failed to fix hooks for session '%s': %v\n", session.Core.Name, err)
                }</span> else<span class="cov0" title="0"> if updated </span><span class="cov0" title="0">{
                        fmt.Printf("‚úÖ Fixed hooks for session '%s'\n", session.Core.Name)
                        fixed++
                }</span>
        }

        <span class="cov0" title="0">if fixed == 0 </span><span class="cov0" title="0">{
                fmt.Println("All session hooks are already correctly configured.")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\nüéâ Fixed hooks for %d session(s)\n", fixed)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// fixSettingsFile updates the settings.json file with correct hook paths
func fixSettingsFile(settingsPath, sessionID, correctPath string) (bool, error) <span class="cov0" title="0">{
        // Check if settings file exists
        if _, err := os.Stat(settingsPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("settings.json not found")
        }</span>

        // Read current settings
        <span class="cov0" title="0">data, err := os.ReadFile(settingsPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read settings file: %w", err)
        }</span>

        <span class="cov0" title="0">var settings map[string]interface{}
        if err := json.Unmarshal(data, &amp;settings); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse settings JSON: %w", err)
        }</span>

        // Check if hooks exist
        <span class="cov0" title="0">hooks, ok := settings["hooks"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                // No hooks section, create it
                hooks = make(map[string]interface{})
                settings["hooks"] = hooks
        }</span>

        // Check if any hooks need updating
        <span class="cov0" title="0">needsUpdate := false
        expectedHooks := map[string]interface{}{
                "Notification": []map[string]interface{}{
                        {
                                "matcher": "",
                                "hooks": []map[string]interface{}{
                                        {
                                                "type":    "command",
                                                "command": fmt.Sprintf("%s __hook %s notification", correctPath, sessionID),
                                        },
                                },
                        },
                },
                "Stop": []map[string]interface{}{
                        {
                                "matcher": "",
                                "hooks": []map[string]interface{}{
                                        {
                                                "type":    "command",
                                                "command": fmt.Sprintf("%s __hook %s stop", correctPath, sessionID),
                                        },
                                },
                        },
                },
                "PreToolUse": []map[string]interface{}{
                        {
                                "matcher": "",
                                "hooks": []map[string]interface{}{
                                        {
                                                "type":    "command",
                                                "command": fmt.Sprintf("%s __hook %s pre_tool_use", correctPath, sessionID),
                                        },
                                },
                        },
                },
                "PostToolUse": []map[string]interface{}{
                        {
                                "matcher": "",
                                "hooks": []map[string]interface{}{
                                        {
                                                "type":    "command",
                                                "command": fmt.Sprintf("%s __hook %s post_tool_use", correctPath, sessionID),
                                        },
                                },
                        },
                },
                "SubagentStop": []map[string]interface{}{
                        {
                                "matcher": "",
                                "hooks": []map[string]interface{}{
                                        {
                                                "type":    "command",
                                                "command": fmt.Sprintf("%s __hook %s subagent_stop", correctPath, sessionID),
                                        },
                                },
                        },
                },
                "PreCompact": []map[string]interface{}{
                        {
                                "matcher": "",
                                "hooks": []map[string]interface{}{
                                        {
                                                "type":    "command",
                                                "command": fmt.Sprintf("%s __hook %s pre_compact", correctPath, sessionID),
                                        },
                                },
                        },
                },
        }

        for hookName, expectedHook := range expectedHooks </span><span class="cov0" title="0">{
                currentHook, exists := hooks[hookName]
                if !exists </span><span class="cov0" title="0">{
                        needsUpdate = true
                        hooks[hookName] = expectedHook
                }</span> else<span class="cov0" title="0"> {
                        // Check if current hook matches expected structure
                        expectedJSON, _ := json.Marshal(expectedHook)
                        currentJSON, _ := json.Marshal(currentHook)
                        if string(expectedJSON) != string(currentJSON) </span><span class="cov0" title="0">{
                                needsUpdate = true
                                hooks[hookName] = expectedHook
                        }</span>
                }
        }

        <span class="cov0" title="0">if !needsUpdate </span><span class="cov0" title="0">{
                return false, nil // No changes needed
        }</span>

        // Write updated settings
        <span class="cov0" title="0">updatedData, err := json.MarshalIndent(settings, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to marshal updated settings: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(settingsPath, updatedData, 0644); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to write updated settings: %w", err)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// getCwtExecutablePath duplicates the logic from state manager for consistency
func getCwtExecutablePath() string <span class="cov0" title="0">{
        // First, try to find cwt in PATH (most reliable for installed binaries)
        if path, err := exec.LookPath("cwt"); err == nil </span><span class="cov0" title="0">{
                return path
        }</span>

        // Check if we're running from go run (has temp executable path)
        <span class="cov0" title="0">if execPath, err := os.Executable(); err == nil </span><span class="cov0" title="0">{
                // If it's a temp path from go run, use "go run cmd/cwt/main.go" instead
                if strings.Contains(execPath, "go-build") || strings.Contains(execPath, "/tmp/") </span><span class="cov0" title="0">{
                        // Check if we're in the cwt project directory
                        if _, err := os.Stat("cmd/cwt/main.go"); err == nil </span><span class="cov0" title="0">{
                                return "go run cmd/cwt/main.go"
                        }</span>
                } else<span class="cov0" title="0"> {
                        // It's a real executable path
                        return execPath
                }</span>
        }

        // Final fallback to "cwt" in PATH
        <span class="cov0" title="0">return "cwt"</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cli

import (
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// newHookCmd creates the hidden hook command for Claude Code integration
func newHookCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:     "__hook [session-id] [event-type]",
                Aliases: []string{"hook"}, // Add alias for troubleshooting
                Hidden:  true,             // Don't show in help output
                Short:   "Internal hook handler for Claude Code events",
                Long: `This is an internal command used by Claude Code hooks.
It receives session events and updates session state files.

This command is automatically configured when creating sessions
and should not be called manually.`,
                Args: cobra.MinimumNArgs(2),
                RunE: runHookCmd,
        }

        return cmd
}</span>

func runHookCmd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        sessionID := args[0]
        eventType := args[1]

        // Debug: log what we received (comment out in production)
        // fmt.Fprintf(os.Stderr, "Hook called with args: %v\n", args)

        // Read hook data from stdin (Claude passes JSON data)
        var eventData map[string]interface{}
        if err := json.NewDecoder(os.Stdin).Decode(&amp;eventData); err != nil </span><span class="cov0" title="0">{
                // If no JSON data, use empty map
                eventData = make(map[string]interface{})
        }</span>

        // Extract message if present
        <span class="cov0" title="0">var lastMessage string
        if msg, ok := eventData["message"].(string); ok </span><span class="cov0" title="0">{
                lastMessage = msg
        }</span>

        // Create session state update
        <span class="cov0" title="0">state := &amp;types.SessionState{
                SessionID:     sessionID,
                ClaudeState:   types.ParseClaudeStateFromEvent(eventType, eventData),
                LastEvent:     eventType,
                LastEventTime: time.Now(),
                LastEventData: eventData,
                LastMessage:   lastMessage,
                LastUpdated:   time.Now(),
        }

        // Save session state (using .cwt as default data directory)
        dataDir := ".cwt"
        if err := types.SaveSessionState(dataDir, state); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save session state: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cli

import (
        "fmt"
        "sort"
        "strings"
        "time"

        "github.com/mattn/go-runewidth"
        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/types"
)

func newListCmd() *cobra.Command <span class="cov8" title="1">{
        var verbose bool

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List all sessions with their current status",
                Long: `List all CWT sessions with derived status from:
- Tmux session alive status
- Git working tree changes
- Claude activity and availability

Status is derived fresh from external systems for accuracy.`,
                Aliases: []string{"ls"},
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runListCmd(verbose)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Show detailed information")

        return cmd</span>
}

func runListCmd(verbose bool) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        // Derive fresh sessions
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions found.")
                fmt.Println("\nCreate a new session with: cwt new [session-name] [task-description]")
                return nil
        }</span>

        // Sort sessions by creation time (newest first)
        <span class="cov0" title="0">sort.Slice(sessions, func(i, j int) bool </span><span class="cov0" title="0">{
                return sessions[i].Core.CreatedAt.After(sessions[j].Core.CreatedAt)
        }</span>)

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                renderVerboseSessionList(sessions)
        }</span> else<span class="cov0" title="0"> {
                renderCompactSessionList(sessions)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func renderCompactSessionList(sessions []types.Session) <span class="cov0" title="0">{
        fmt.Printf("Found %d session(s):\n\n", len(sessions))

        // Calculate max widths for each column based on content
        maxNameLen := 4     // "NAME"
        maxTmuxLen := 4     // "TMUX"
        maxClaudeLen := 6   // "CLAUDE"
        maxGitLen := 3      // "GIT"
        maxActivityLen := 8 // "ACTIVITY"

        // Pre-format all data to calculate actual widths
        type rowData struct {
                name     string
                tmux     string
                claude   string
                git      string
                activity string
        }

        rows := make([]rowData, len(sessions))
        for i, session := range sessions </span><span class="cov0" title="0">{
                rows[i] = rowData{
                        name:     truncate(session.Core.Name, 30),
                        tmux:     formatTmuxStatus(session.IsAlive),
                        claude:   formatClaudeStatus(session.ClaudeStatus),
                        git:      formatGitStatus(session.GitStatus),
                        activity: FormatActivity(session.LastActivity),
                }

                // Update max lengths (using visual length)
                if l := visualLength(rows[i].name); l &gt; maxNameLen </span><span class="cov0" title="0">{
                        maxNameLen = l
                }</span>
                <span class="cov0" title="0">if l := visualLength(rows[i].tmux); l &gt; maxTmuxLen </span><span class="cov0" title="0">{
                        maxTmuxLen = l
                }</span>
                <span class="cov0" title="0">if l := visualLength(rows[i].claude); l &gt; maxClaudeLen </span><span class="cov0" title="0">{
                        maxClaudeLen = l
                }</span>
                <span class="cov0" title="0">if l := visualLength(rows[i].git); l &gt; maxGitLen </span><span class="cov0" title="0">{
                        maxGitLen = l
                }</span>
                <span class="cov0" title="0">if l := visualLength(rows[i].activity); l &gt; maxActivityLen </span><span class="cov0" title="0">{
                        maxActivityLen = l
                }</span>
        }

        // Add padding
        <span class="cov0" title="0">maxNameLen += 2
        maxTmuxLen += 2
        maxClaudeLen += 2
        maxGitLen += 2
        maxActivityLen += 2

        // Print header
        fmt.Printf("%s  %s  %s  %s  %s\n",
                padRight("NAME", maxNameLen),
                padRight("TMUX", maxTmuxLen),
                padRight("CLAUDE", maxClaudeLen),
                padRight("GIT", maxGitLen),
                padRight("ACTIVITY", maxActivityLen))

        fmt.Printf("%s  %s  %s  %s  %s\n",
                strings.Repeat("-", maxNameLen),
                strings.Repeat("-", maxTmuxLen),
                strings.Repeat("-", maxClaudeLen),
                strings.Repeat("-", maxGitLen),
                strings.Repeat("-", maxActivityLen))

        // Print rows
        for _, row := range rows </span><span class="cov0" title="0">{
                fmt.Printf("%s  %s  %s  %s  %s\n",
                        padRight(row.name, maxNameLen),
                        padRight(row.tmux, maxTmuxLen),
                        padRight(row.claude, maxClaudeLen),
                        padRight(row.git, maxGitLen),
                        padRight(row.activity, maxActivityLen))
        }</span>
}

func renderVerboseSessionList(sessions []types.Session) <span class="cov0" title="0">{
        fmt.Printf("Found %d session(s):\n\n", len(sessions))

        for i, session := range sessions </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">fmt.Printf("üè∑Ô∏è  %s\n", session.Core.Name)
                fmt.Printf("   ID: %s\n", session.Core.ID)
                fmt.Printf("   Created: %s\n", session.Core.CreatedAt.Format("2006-01-02 15:04:05"))
                fmt.Printf("   Worktree: %s\n", session.Core.WorktreePath)
                fmt.Printf("   \n")

                // Tmux status
                fmt.Printf("   üñ•Ô∏è  Tmux: %s (session: %s)\n",
                        formatTmuxStatus(session.IsAlive), session.Core.TmuxSession)

                // Git status
                gitDetails := ""
                if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                        changes := []string{}
                        if len(session.GitStatus.ModifiedFiles) &gt; 0 </span><span class="cov0" title="0">{
                                changes = append(changes, fmt.Sprintf("%d modified", len(session.GitStatus.ModifiedFiles)))
                        }</span>
                        <span class="cov0" title="0">if len(session.GitStatus.AddedFiles) &gt; 0 </span><span class="cov0" title="0">{
                                changes = append(changes, fmt.Sprintf("%d added", len(session.GitStatus.AddedFiles)))
                        }</span>
                        <span class="cov0" title="0">if len(session.GitStatus.DeletedFiles) &gt; 0 </span><span class="cov0" title="0">{
                                changes = append(changes, fmt.Sprintf("%d deleted", len(session.GitStatus.DeletedFiles)))
                        }</span>
                        <span class="cov0" title="0">gitDetails = fmt.Sprintf(" (%s)", strings.Join(changes, ", "))</span>
                }
                <span class="cov0" title="0">fmt.Printf("   üìÅ Git: %s%s\n", formatGitStatus(session.GitStatus), gitDetails)

                // Claude status
                claudeDetails := ""
                if session.ClaudeStatus.SessionID != "" </span><span class="cov0" title="0">{
                        claudeDetails = fmt.Sprintf(" (session: %s)", session.ClaudeStatus.SessionID)
                }</span>
                <span class="cov0" title="0">if !session.ClaudeStatus.LastMessage.IsZero() </span><span class="cov0" title="0">{
                        age := time.Since(session.ClaudeStatus.LastMessage)
                        claudeDetails += fmt.Sprintf(" (last: %s ago)", FormatDuration(age))
                }</span>
                <span class="cov0" title="0">fmt.Printf("   ü§ñ Claude: %s%s\n", formatClaudeStatusShort(session.ClaudeStatus), claudeDetails)

                // Show full message in verbose mode if available
                if session.ClaudeStatus.StatusMessage != "" </span><span class="cov0" title="0">{
                        fmt.Printf("      Message: %s\n", session.ClaudeStatus.StatusMessage)
                }</span>

                // Last activity
                <span class="cov0" title="0">fmt.Printf("   ‚è∞ Activity: %s\n", FormatActivity(session.LastActivity))</span>
        }
}

func formatTmuxStatus(isAlive bool) string <span class="cov0" title="0">{
        if isAlive </span><span class="cov0" title="0">{
                return "üü¢ alive"
        }</span>
        <span class="cov0" title="0">return "üî¥ dead"</span>
}

func formatClaudeStatusShort(status types.ClaudeStatus) string <span class="cov0" title="0">{
        switch status.State </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                return "üîÑ working"</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                return "‚è∏Ô∏è waiting"</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                return "‚úÖ complete"</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                return "üí§ idle"</span>
        default:<span class="cov0" title="0">
                return "‚ùì unknown"</span>
        }
}

func formatClaudeStatus(status types.ClaudeStatus) string <span class="cov0" title="0">{
        switch status.State </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                return "üîÑ working"</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                if status.StatusMessage != "" </span><span class="cov0" title="0">{
                        // Truncate message for compact view
                        msg := status.StatusMessage
                        if len(msg) &gt; 30 </span><span class="cov0" title="0">{
                                msg = msg[:27] + "..."
                        }</span>
                        <span class="cov0" title="0">return "‚è∏Ô∏è " + msg</span>
                }
                <span class="cov0" title="0">return "‚è∏Ô∏è waiting"</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                return "‚úÖ complete"</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                return "üí§ idle"</span>
        default:<span class="cov0" title="0">
                return "‚ùì unknown"</span>
        }
}

func formatGitStatus(status types.GitStatus) string <span class="cov0" title="0">{
        if status.HasChanges </span><span class="cov0" title="0">{
                // Calculate total changes
                total := len(status.ModifiedFiles) + len(status.AddedFiles) +
                        len(status.DeletedFiles) + len(status.UntrackedFiles)

                if total == 1 </span><span class="cov0" title="0">{
                        return "üìù 1 change"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("üìù %d changes", total)</span>
        }
        <span class="cov0" title="0">return "‚ú® clean"</span>
}

func FormatActivity(lastActivity time.Time) string <span class="cov0" title="0">{
        if lastActivity.IsZero() </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">age := time.Since(lastActivity)
        if age &lt; time.Minute </span><span class="cov0" title="0">{
                return "just now"
        }</span>
        <span class="cov0" title="0">return FormatDuration(age) + " ago"</span>
}

func FormatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return "just now"
        }</span>
        <span class="cov0" title="0">if d &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(d.Minutes())
                return fmt.Sprintf("%dm", minutes)
        }</span>
        <span class="cov0" title="0">if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(d.Hours())
                return fmt.Sprintf("%dh", hours)
        }</span>
        <span class="cov0" title="0">days := int(d.Hours() / 24)
        return fmt.Sprintf("%dd", days)</span>
}

func truncate(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">if maxLen &lt;= 3 </span><span class="cov0" title="0">{
                return s[:maxLen]
        }</span>
        <span class="cov0" title="0">return s[:maxLen-3] + "..."</span>
}

// visualLength calculates the visual display width of a string using runewidth
func visualLength(s string) int <span class="cov0" title="0">{
        return runewidth.StringWidth(s)
}</span>

// padRight pads a string to the specified visual width
func padRight(s string, width int) string <span class="cov0" title="0">{
        currentWidth := runewidth.StringWidth(s)
        if currentWidth &gt;= width </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s + strings.Repeat(" ", width-currentWidth)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// newMergeCmd creates the 'cwt merge' command
func newMergeCmd() *cobra.Command <span class="cov8" title="1">{
        var target string
        var squash bool
        var dryRun bool

        cmd := &amp;cobra.Command{
                Use:   "merge &lt;session-name&gt;",
                Short: "Merge session changes back to target branch",
                Long: `Safely integrate session changes back to target branches with conflict resolution.

Examples:
  cwt merge my-session              # Interactive merge to current branch
  cwt merge my-session --target main  # Merge to specific target branch
  cwt merge my-session --squash     # Squash merge for clean history
  cwt merge my-session --dry-run    # Preview merge without executing`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sm, err := createStateManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer sm.Close()

                        sessionName := args[0]
                        return mergeSession(sm, sessionName, target, squash, dryRun)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVar(&amp;target, "target", "", "Target branch to merge into (default: current branch)")
        cmd.Flags().BoolVar(&amp;squash, "squash", false, "Squash merge for clean history")
        cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Preview merge without executing")

        return cmd</span>
}

// mergeSession merges a session's changes into the target branch
func mergeSession(sm *state.Manager, sessionName, target string, squash, dryRun bool) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        // Find the session
        <span class="cov0" title="0">var targetSession *types.Session
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.Core.Name == sessionName </span><span class="cov0" title="0">{
                        targetSession = &amp;session
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetSession == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session '%s' not found", sessionName)
        }</span>

        // Determine target branch
        <span class="cov0" title="0">if target == "" </span><span class="cov0" title="0">{
                currentBranch, err := getCurrentBranch()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get current branch: %w", err)
                }</span>
                <span class="cov0" title="0">target = currentBranch</span>
        }

        <span class="cov0" title="0">sessionBranch := fmt.Sprintf("cwt-%s", sessionName)

        // Validate pre-merge conditions
        if err := validateMergeConditions(target, sessionBranch); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Show merge preview
        <span class="cov0" title="0">if err := showMergePreview(sessionBranch, target); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to show merge preview: %w", err)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                fmt.Println("\nDry run completed. No changes were made.")
                return nil
        }</span>

        // Confirm merge unless dry run
        <span class="cov0" title="0">if !confirmMerge(sessionName, target, squash) </span><span class="cov0" title="0">{
                fmt.Println("Merge cancelled")
                return nil
        }</span>

        // Perform the merge
        <span class="cov0" title="0">if err := performMerge(sessionBranch, target, squash); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("merge failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully merged session '%s' into '%s'\n", sessionName, target)

        // Update session status (this would require extending the Session type)
        // For now, just print success message

        return nil</span>
}

// validateMergeConditions checks if merge can proceed safely
func validateMergeConditions(targetBranch, sessionBranch string) error <span class="cov0" title="0">{
        // Check if target branch exists
        if !branchExists(targetBranch) </span><span class="cov0" title="0">{
                return fmt.Errorf("target branch '%s' does not exist", targetBranch)
        }</span>

        // Check if session branch exists
        <span class="cov0" title="0">if !branchExists(sessionBranch) </span><span class="cov0" title="0">{
                return fmt.Errorf("session branch '%s' does not exist", sessionBranch)
        }</span>

        // Check for uncommitted changes in target branch
        <span class="cov0" title="0">currentBranch, err := getCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current branch: %w", err)
        }</span>

        <span class="cov0" title="0">if currentBranch == targetBranch &amp;&amp; hasUncommittedChanges() </span><span class="cov0" title="0">{
                return fmt.Errorf("target branch '%s' has uncommitted changes. Please commit or stash them first", targetBranch)
        }</span>

        // Check if session branch is ahead of target
        <span class="cov0" title="0">if !branchIsAhead(sessionBranch, targetBranch) </span><span class="cov0" title="0">{
                return fmt.Errorf("session branch '%s' is not ahead of target branch '%s'", sessionBranch, targetBranch)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// showMergePreview displays what will be merged
func showMergePreview(sessionBranch, targetBranch string) error <span class="cov0" title="0">{
        fmt.Printf("Merge Preview: %s -&gt; %s\n", sessionBranch, targetBranch)
        fmt.Println(strings.Repeat("=", 50))

        // Show commit summary
        cmd := exec.Command("git", "log", "--oneline", fmt.Sprintf("%s..%s", targetBranch, sessionBranch))
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to show commit summary: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println(strings.Repeat("=", 50))

        // Show file changes summary
        cmd = exec.Command("git", "diff", "--stat", targetBranch, sessionBranch)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to show file changes: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// confirmMerge asks user for confirmation
func confirmMerge(sessionName, target string, squash bool) bool <span class="cov0" title="0">{
        mergeType := "merge"
        if squash </span><span class="cov0" title="0">{
                mergeType = "squash merge"
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nProceed with %s of session '%s' into '%s'? (y/N): ", mergeType, sessionName, target)

        var response string
        fmt.Scanln(&amp;response)

        response = strings.ToLower(strings.TrimSpace(response))
        return response == "y" || response == "yes"</span>
}

// performMerge executes the actual merge
func performMerge(sessionBranch, targetBranch string, squash bool) error <span class="cov0" title="0">{
        // Switch to target branch first
        if err := switchBranch(targetBranch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to switch to target branch '%s': %w", targetBranch, err)
        }</span>

        // Prepare merge command
        <span class="cov0" title="0">var cmd *exec.Cmd
        if squash </span><span class="cov0" title="0">{
                cmd = exec.Command("git", "merge", "--squash", sessionBranch)
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("git", "merge", "--no-ff", sessionBranch, "-m", fmt.Sprintf("Merge session branch %s", sessionBranch))
        }</span>

        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // If merge failed, try to provide helpful error message
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        if exitError.ExitCode() == 1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("merge conflicts detected. Please resolve conflicts and run 'git commit' to complete the merge")
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("merge command failed: %w", err)</span>
        }

        // If squash merge, we need to commit the changes
        <span class="cov0" title="0">if squash </span><span class="cov0" title="0">{
                commitMsg := fmt.Sprintf("Squash merge session %s", strings.TrimPrefix(sessionBranch, "cwt-"))
                cmd = exec.Command("git", "commit", "-m", commitMsg)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to commit squash merge: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions for git operations

func branchExists(branch string) bool <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "--verify", branch)
        return cmd.Run() == nil
}</span>

func branchIsAhead(sourceBranch, targetBranch string) bool <span class="cov0" title="0">{
        // Check if source branch has commits that target doesn't have
        cmd := exec.Command("git", "rev-list", "--count", fmt.Sprintf("%s..%s", targetBranch, sourceBranch))
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">count := strings.TrimSpace(string(output))
        return count != "0"</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/operations"
)

func newNewCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "new [session-name]",
                Short: "Create a new session with isolated git worktree and tmux session",
                Long: `Create a new CWT session with:
- Isolated git worktree in .cwt/worktrees/[session-name]
- New tmux session running Claude Code
- Session metadata persistence

If session-name is not provided, you will be prompted interactively.`,
                Args: cobra.MaximumNArgs(1),
                RunE: runNewCmd,
        }

        return cmd
}</span>

func runNewCmd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        // Get session name
        var sessionName string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                sessionName = args[0]
        }</span> else<span class="cov0" title="0"> {
                sessionName, err = promptForSessionName()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Create session using operations layer
        <span class="cov0" title="0">fmt.Printf("Creating session '%s'...\n", sessionName)

        sessionOps := operations.NewSessionOperations(sm)
        if err := sessionOps.CreateSession(sessionName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create session: %w", err)
        }</span>

        // Success message
        <span class="cov0" title="0">fmt.Printf("‚úÖ Session '%s' created successfully!\n\n", sessionName)
        fmt.Printf("Next steps:\n")
        fmt.Printf("  ‚Ä¢ View all sessions: cwt list\n")
        fmt.Printf("  ‚Ä¢ Attach to session: cwt attach %s\n", sessionName)
        fmt.Printf("  ‚Ä¢ Open TUI dashboard: cwt tui\n")
        fmt.Printf("  ‚Ä¢ Work in isolated directory: cd %s/worktrees/%s\n", dataDir, sessionName)

        return nil</span>
}

func promptForSessionName() (string, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Print("Enter session name: ")
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">sessionName := strings.TrimSpace(input)
                if sessionName == "" </span><span class="cov0" title="0">{
                        fmt.Println("Session name cannot be empty. Please try again.")
                        continue</span>
                }

                <span class="cov0" title="0">return sessionName, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cli

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// newPublishCmd creates the 'cwt publish' command
func newPublishCmd() *cobra.Command <span class="cov8" title="1">{
        var draft bool
        var pr bool
        var localOnly bool
        var message string

        cmd := &amp;cobra.Command{
                Use:   "publish &lt;session-name&gt;",
                Short: "Commit all session changes and publish the branch",
                Long: `Commit all session changes and publish the branch for collaboration or backup.

Examples:
  cwt publish my-session                # Commit all changes + push branch
  cwt publish my-session --draft        # Push as draft PR (if GitHub CLI available)
  cwt publish my-session --pr           # Create PR automatically
  cwt publish my-session --local        # Commit only, no push
  cwt publish my-session -m "Custom commit message"  # Use custom commit message`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sm, err := createStateManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer sm.Close()

                        sessionName := args[0]
                        return publishSession(sm, sessionName, message, draft, pr, localOnly)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;draft, "draft", false, "Push as draft PR (requires GitHub CLI)")
        cmd.Flags().BoolVar(&amp;pr, "pr", false, "Create PR automatically (requires GitHub CLI)")
        cmd.Flags().BoolVar(&amp;localOnly, "local", false, "Commit only, no push")
        cmd.Flags().StringVarP(&amp;message, "message", "m", "", "Custom commit message")

        return cmd</span>
}

// publishSession commits and publishes a session's changes
func publishSession(sm *state.Manager, sessionName, customMessage string, draft, pr, localOnly bool) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        // Find the session
        <span class="cov0" title="0">var targetSession *types.Session
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.Core.Name == sessionName </span><span class="cov0" title="0">{
                        targetSession = &amp;session
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetSession == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session '%s' not found", sessionName)
        }</span>

        <span class="cov0" title="0">if !targetSession.IsAlive </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Session '%s' is not currently active\n", sessionName)
        }</span>

        <span class="cov0" title="0">worktreePath := targetSession.Core.WorktreePath
        sessionBranch := fmt.Sprintf("cwt-%s", sessionName)

        // Switch to the session's worktree directory
        originalDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Chdir(originalDir)

        if err := os.Chdir(worktreePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change to worktree directory: %w", err)
        }</span>

        // Check if there are changes to commit
        <span class="cov0" title="0">if !hasChangesToCommit() </span><span class="cov0" title="0">{
                fmt.Printf("No changes to commit in session '%s'\n", sessionName)
                if !localOnly </span><span class="cov0" title="0">{
                        // Still try to push in case there are unpushed commits
                        return pushBranch(sessionBranch, draft, pr)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Generate commit message
        <span class="cov0" title="0">commitMessage := customMessage
        if commitMessage == "" </span><span class="cov0" title="0">{
                commitMessage = generateCommitMessage(sessionName, worktreePath)
        }</span>

        // Stage and commit changes
        <span class="cov0" title="0">if err := stageAndCommit(commitMessage); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit changes: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Committed changes in session '%s'\n", sessionName)

        // Push if not local-only
        if !localOnly </span><span class="cov0" title="0">{
                if err := pushBranch(sessionBranch, draft, pr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to push branch: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// hasChangesToCommit checks if there are changes to commit
func hasChangesToCommit() bool <span class="cov0" title="0">{
        // Check for staged changes
        cmd := exec.Command("git", "diff", "--cached", "--quiet")
        if cmd.Run() != nil </span><span class="cov0" title="0">{
                return true // Has staged changes
        }</span>

        // Check for unstaged changes
        <span class="cov0" title="0">cmd = exec.Command("git", "diff", "--quiet")
        if cmd.Run() != nil </span><span class="cov0" title="0">{
                return true // Has unstaged changes
        }</span>

        // Check for untracked files
        <span class="cov0" title="0">cmd = exec.Command("git", "ls-files", "--others", "--exclude-standard")
        output, err := cmd.Output()
        if err == nil &amp;&amp; len(strings.TrimSpace(string(output))) &gt; 0 </span><span class="cov0" title="0">{
                return true // Has untracked files
        }</span>

        <span class="cov0" title="0">return false</span>
}

// generateCommitMessage creates an intelligent commit message
func generateCommitMessage(sessionName, worktreePath string) string <span class="cov0" title="0">{
        // Try to read Claude's recent activity to understand what was done
        claudeMessage := extractClaudeWorkSummary(worktreePath)
        if claudeMessage != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("feat(%s): %s\n\nü§ñ Generated with Claude Code\n\nCo-Authored-By: Claude &lt;noreply@anthropic.com&gt;", sessionName, claudeMessage)
        }</span>

        // Fallback to generic message with file analysis
        <span class="cov0" title="0">changes := analyzeChanges()
        if changes != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("feat(%s): %s\n\nü§ñ Generated with Claude Code\n\nCo-Authored-By: Claude &lt;noreply@anthropic.com&gt;", sessionName, changes)
        }</span>

        // Final fallback
        <span class="cov0" title="0">return fmt.Sprintf("feat(%s): Update session changes\n\nü§ñ Generated with Claude Code\n\nCo-Authored-By: Claude &lt;noreply@anthropic.com&gt;", sessionName)</span>
}

// extractClaudeWorkSummary tries to extract what Claude was working on
func extractClaudeWorkSummary(worktreePath string) string <span class="cov0" title="0">{
        // Look for Claude's session state or recent JSONL activity
        sessionStateDir := filepath.Join(worktreePath, ".claude", "session_state")

        // This is a simplified implementation - in a full version,
        // you'd parse Claude's actual activity logs
        if _, err := os.Stat(sessionStateDir); err == nil </span><span class="cov0" title="0">{
                return "implement new features and improvements"
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// analyzeChanges analyzes git diff to create a descriptive commit message
func analyzeChanges() string <span class="cov0" title="0">{
        // Get list of modified files
        cmd := exec.Command("git", "diff", "--name-only", "HEAD")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "update files"
        }</span>

        <span class="cov0" title="0">files := strings.Split(strings.TrimSpace(string(output)), "\n")
        if len(files) == 0 || files[0] == "" </span><span class="cov0" title="0">{
                // Check staged files
                cmd = exec.Command("git", "diff", "--cached", "--name-only")
                output, err = cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return "update files"
                }</span>
                <span class="cov0" title="0">files = strings.Split(strings.TrimSpace(string(output)), "\n")</span>
        }

        <span class="cov0" title="0">if len(files) == 0 || files[0] == "" </span><span class="cov0" title="0">{
                return "update files"
        }</span>

        // Analyze file types and create descriptive message
        <span class="cov0" title="0">var goFiles, jsFiles, pyFiles, otherFiles int

        for _, file := range files </span><span class="cov0" title="0">{
                if file == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ext := filepath.Ext(file)
                switch ext </span>{
                case ".go":<span class="cov0" title="0">
                        goFiles++</span>
                case ".js", ".ts", ".jsx", ".tsx":<span class="cov0" title="0">
                        jsFiles++</span>
                case ".py":<span class="cov0" title="0">
                        pyFiles++</span>
                default:<span class="cov0" title="0">
                        otherFiles++</span>
                }
        }

        <span class="cov0" title="0">if len(files) == 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("update %s", files[0])
        }</span>

        <span class="cov0" title="0">var parts []string
        if goFiles &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%d Go files", goFiles))
        }</span>
        <span class="cov0" title="0">if jsFiles &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%d JS/TS files", jsFiles))
        }</span>
        <span class="cov0" title="0">if pyFiles &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%d Python files", pyFiles))
        }</span>
        <span class="cov0" title="0">if otherFiles &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%d other files", otherFiles))
        }</span>

        <span class="cov0" title="0">if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("update %s", strings.Join(parts, ", "))
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("update %d files", len(files))</span>
}

// stageAndCommit stages all changes and commits them
func stageAndCommit(message string) error <span class="cov0" title="0">{
        // Add all changes (including untracked files)
        cmd := exec.Command("git", "add", ".")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stage changes: %w", err)
        }</span>

        // Commit changes
        <span class="cov0" title="0">cmd = exec.Command("git", "commit", "-m", message)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// pushBranch pushes the branch and optionally creates PR
func pushBranch(branch string, draft, pr bool) error <span class="cov0" title="0">{
        // Check if remote exists
        if !hasRemote() </span><span class="cov0" title="0">{
                fmt.Println("No remote repository configured, skipping push")
                return nil
        }</span>

        // Push branch with upstream tracking
        <span class="cov0" title="0">fmt.Printf("Pushing branch '%s'...\n", branch)
        cmd := exec.Command("git", "push", "-u", "origin", branch)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to push branch: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully pushed branch '%s'\n", branch)

        // Create PR if requested and GitHub CLI is available
        if (draft || pr) &amp;&amp; hasGitHubCLI() </span><span class="cov0" title="0">{
                return createPullRequest(branch, draft)
        }</span> else<span class="cov0" title="0"> if draft || pr </span><span class="cov0" title="0">{
                fmt.Println("GitHub CLI not found, skipping PR creation")
                fmt.Printf("You can manually create a PR for branch '%s'\n", branch)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// hasRemote checks if a remote repository is configured
func hasRemote() bool <span class="cov0" title="0">{
        cmd := exec.Command("git", "remote")
        output, err := cmd.Output()
        return err == nil &amp;&amp; len(strings.TrimSpace(string(output))) &gt; 0
}</span>

// hasGitHubCLI checks if GitHub CLI is available
func hasGitHubCLI() bool <span class="cov0" title="0">{
        cmd := exec.Command("gh", "--version")
        return cmd.Run() == nil
}</span>

// createPullRequest creates a pull request using GitHub CLI
func createPullRequest(branch string, draft bool) error <span class="cov0" title="0">{
        sessionName := strings.TrimPrefix(branch, "cwt-")
        title := fmt.Sprintf("feat(%s): Session changes", sessionName)

        body := fmt.Sprintf(`## Summary
Changes from CWT session: %s

## Generated Context
- Session branch: %s
- Created: %s

ü§ñ Generated with [Claude Code](https://claude.ai/code)`,
                sessionName,
                branch,
                time.Now().Format("2006-01-02 15:04:05"))

        args := []string{"pr", "create", "--title", title, "--body", body}
        if draft </span><span class="cov0" title="0">{
                args = append(args, "--draft")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Creating pull request for branch '%s'...\n", branch)
        cmd := exec.Command("gh", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pull request: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
)

var (
        dataDir    string
        baseBranch string
)

// NewRootCmd creates the root command for the CWT CLI
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{
        rootCmd := &amp;cobra.Command{
                Use:   "cwt",
                Short: "Claude Worktree Tool - Manage multiple Claude Code sessions with isolated git worktrees",
                Long: `CWT (Claude Worktree Tool) is a control plane for managing multiple Claude Code sessions
with isolated git worktrees. Think of it as a project management system where you are 
the engineering manager and Claude Code sessions are your engineers working on isolated tasks.`,
                SilenceUsage:  true,
                SilenceErrors: true,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // When no subcommand is provided, launch TUI
                        return runTuiCmd(cmd, args)
                }</span>,
        }

        // Set custom help template
        <span class="cov8" title="1">rootCmd.SetHelpTemplate(getCustomHelpTemplate())

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;dataDir, "data-dir", ".cwt", "Directory for storing session data")
        rootCmd.PersistentFlags().StringVar(&amp;baseBranch, "base-branch", "main", "Base branch for creating worktrees")

        // Add subcommands with annotations for grouping

        // Session Management
        sessionMgmt := []*cobra.Command{
                addAnnotation(newNewCmd(), "session-mgmt"),
                addAnnotation(newAttachCmd(), "session-mgmt"),
                addAnnotation(newDeleteCmd(), "session-mgmt"),
                addAnnotation(newCleanupCmd(), "session-mgmt"),
        }

        // Session Workflow (Branch Lifecycle)
        sessionWorkflow := []*cobra.Command{
                addAnnotation(newSwitchCmd(), "session-workflow"),
                addAnnotation(newMergeCmd(), "session-workflow"),
                addAnnotation(newPublishCmd(), "session-workflow"),
        }

        // Information &amp; Monitoring
        info := []*cobra.Command{
                addAnnotation(newListCmd(), "info"),
                addAnnotation(newStatusCmd(), "info"),
                addAnnotation(newDiffCmd(), "info"),
        }

        // Interface &amp; Utilities
        interface_utils := []*cobra.Command{
                addAnnotation(newTuiCmd(), "interface"),
                addAnnotation(newFixHooksCmd(), "interface"),
        }

        // Hidden/Internal commands (no annotation needed)
        hidden := []*cobra.Command{
                newHookCmd(), // Hidden internal command
        }

        // Add all commands
        for _, cmd := range sessionMgmt </span><span class="cov8" title="1">{
                rootCmd.AddCommand(cmd)
        }</span>
        <span class="cov8" title="1">for _, cmd := range sessionWorkflow </span><span class="cov8" title="1">{
                rootCmd.AddCommand(cmd)
        }</span>
        <span class="cov8" title="1">for _, cmd := range info </span><span class="cov8" title="1">{
                rootCmd.AddCommand(cmd)
        }</span>
        <span class="cov8" title="1">for _, cmd := range interface_utils </span><span class="cov8" title="1">{
                rootCmd.AddCommand(cmd)
        }</span>
        <span class="cov8" title="1">for _, cmd := range hidden </span><span class="cov8" title="1">{
                rootCmd.AddCommand(cmd)
        }</span>

        <span class="cov8" title="1">return rootCmd</span>
}

// createStateManager creates a StateManager with the current configuration
func createStateManager() (*state.Manager, error) <span class="cov0" title="0">{
        config := state.Config{
                DataDir:    dataDir,
                BaseBranch: baseBranch,
                // Use real checkers (default behavior)
        }

        sm := state.NewManager(config)

        // Validate git repository by trying to derive sessions
        _, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                // Try to provide helpful error message
                if err.Error() == "not a git repository" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("current directory is not a git repository. Please run 'git init' first")
                }</span>
                <span class="cov0" title="0">if err.Error() == "repository has no commits" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("git repository has no commits. Please make an initial commit first")
                }</span>
                // Return original error for other cases
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return sm, nil</span>
}

// addAnnotation adds a group annotation to a command
func addAnnotation(cmd *cobra.Command, group string) *cobra.Command <span class="cov8" title="1">{
        if cmd.Annotations == nil </span><span class="cov8" title="1">{
                cmd.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">cmd.Annotations["group"] = group
        return cmd</span>
}

// getCustomHelpTemplate returns a custom help template with organized command groups
func getCustomHelpTemplate() string <span class="cov8" title="1">{
        return `{{with (or .Long .Short)}}{{. | trimTrailingWhitespaces}}

{{end}}{{if or .Runnable .HasSubCommands}}{{.UsageString}}{{end}}{{if .HasAvailableSubCommands}}

Session Management:{{range .Commands}}{{if and (eq .Annotations.group "session-mgmt") .IsAvailableCommand}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}

Session Workflow (Branch Lifecycle):{{range .Commands}}{{if and (eq .Annotations.group "session-workflow") .IsAvailableCommand}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}

Information &amp; Monitoring:{{range .Commands}}{{if and (eq .Annotations.group "info") .IsAvailableCommand}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}

Interface &amp; Utilities:{{range .Commands}}{{if and (eq .Annotations.group "interface") .IsAvailableCommand}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}

Other Commands:{{range .Commands}}{{if and (or (not .Annotations.group) (eq .Name "help") (eq .Name "completion")) .IsAvailableCommand}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableInheritedFlags}}

Global Flags:
{{.InheritedFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasAvailableSubCommands}}

Use "{{.CommandPath}} [command] --help" for more information about a command.{{end}}

Workflow Examples:
  cwt new my-feature "Add user authentication"     # Create session
  cwt attach my-feature                           # Work on the feature
  cwt status --summary                            # Check overall progress
  cwt switch my-feature                          # Test changes locally
  cwt publish my-feature                         # Commit and push
  cwt merge my-feature                           # Merge to main branch
  cwt tui                                        # Use interactive dashboard
`
}</span>

// Execute runs the root command
func Execute() <span class="cov0" title="0">{
        rootCmd := NewRootCmd()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import (
        "fmt"
        "os"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// SessionSelectorResult represents the result of session selection
type SessionSelectorResult struct {
        Session  *types.Session
        Canceled bool
}

// sessionSelectorModel represents the session selector state
type sessionSelectorModel struct {
        sessions []types.Session
        cursor   int
        selected bool
        canceled bool
        title    string
        width    int
        height   int
}

// SessionSelectorOption configures the session selector
type SessionSelectorOption func(*sessionSelectorModel)

// WithTitle sets the selector title
func WithTitle(title string) SessionSelectorOption <span class="cov0" title="0">{
        return func(m *sessionSelectorModel) </span><span class="cov0" title="0">{
                m.title = title
        }</span>
}

// WithSessionFilter filters sessions based on a predicate
func WithSessionFilter(filter func(types.Session) bool) SessionSelectorOption <span class="cov0" title="0">{
        return func(m *sessionSelectorModel) </span><span class="cov0" title="0">{
                filtered := make([]types.Session, 0)
                for _, session := range m.sessions </span><span class="cov0" title="0">{
                        if filter(session) </span><span class="cov0" title="0">{
                                filtered = append(filtered, session)
                        }</span>
                }
                <span class="cov0" title="0">m.sessions = filtered</span>
        }
}

// SelectSession shows an interactive session selector
func SelectSession(sessions []types.Session, options ...SessionSelectorOption) (*types.Session, error) <span class="cov0" title="0">{
        if len(sessions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no sessions available")
        }</span>

        <span class="cov0" title="0">if len(sessions) == 1 </span><span class="cov0" title="0">{
                // If only one session, return it directly
                return &amp;sessions[0], nil
        }</span>

        <span class="cov0" title="0">model := &amp;sessionSelectorModel{
                sessions: sessions,
                cursor:   0,
                title:    "Select a session:",
        }

        // Apply options
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(model)
        }</span>

        // Check if we have an interactive terminal
        <span class="cov0" title="0">if !hasInteractiveTerminal() </span><span class="cov0" title="0">{
                // Fallback to simple number-based selection
                return selectSessionFallback(model.sessions, model.title)
        }</span>

        // Try interactive mode, fallback on any error
        <span class="cov0" title="0">p := tea.NewProgram(model)
        finalModel, err := p.Run()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple number-based selection
                return selectSessionFallback(model.sessions, model.title)
        }</span>

        <span class="cov0" title="0">result := finalModel.(*sessionSelectorModel)
        if result.canceled </span><span class="cov0" title="0">{
                return nil, nil // User canceled
        }</span>

        <span class="cov0" title="0">if result.cursor &gt;= 0 &amp;&amp; result.cursor &lt; len(result.sessions) </span><span class="cov0" title="0">{
                return &amp;result.sessions[result.cursor], nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid selection")</span>
}

// hasInteractiveTerminal checks if we're running in an interactive terminal
func hasInteractiveTerminal() bool <span class="cov0" title="0">{
        // Check if stdin and stdout are terminals
        _, stdinErr := os.Stdin.Stat()
        _, stdoutErr := os.Stdout.Stat()
        return stdinErr == nil &amp;&amp; stdoutErr == nil
}</span>

// selectSessionFallback provides a simple number-based fallback when TTY is not available
func selectSessionFallback(sessions []types.Session, title string) (*types.Session, error) <span class="cov0" title="0">{
        fmt.Println(title)
        fmt.Println()

        for i, session := range sessions </span><span class="cov0" title="0">{
                status := getSessionStatusIndicator(session)
                activity := FormatActivity(session.LastActivity)
                fmt.Printf("  %d. %s %s (%s)\n", i+1, session.Core.Name, status, activity)
        }</span>

        <span class="cov0" title="0">fmt.Print("\nEnter session number (or 0 to cancel): ")
        var choice int
        if _, err := fmt.Scanf("%d", &amp;choice); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid input")
        }</span>

        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return nil, nil // User canceled
        }</span>

        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(sessions) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid session number")
        }</span>

        <span class="cov0" title="0">return &amp;sessions[choice-1], nil</span>
}

// Init initializes the selector model
func (m *sessionSelectorModel) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update handles user input
func (m *sessionSelectorModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "ctrl+c", "q", "esc":<span class="cov0" title="0">
                        m.canceled = true
                        return m, tea.Quit</span>

                case "up", "k":<span class="cov0" title="0">
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                        }</span>

                case "down", "j":<span class="cov0" title="0">
                        if m.cursor &lt; len(m.sessions)-1 </span><span class="cov0" title="0">{
                                m.cursor++
                        }</span>

                case "enter", " ":<span class="cov0" title="0">
                        m.selected = true
                        return m, tea.Quit</span>
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the selector inline
func (m *sessionSelectorModel) View() string <span class="cov0" title="0">{
        if len(m.sessions) == 0 </span><span class="cov0" title="0">{
                return "No sessions available. Press q to quit."
        }</span>

        <span class="cov0" title="0">var b strings.Builder

        // Title (more compact)
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("205"))

        b.WriteString(titleStyle.Render(m.title))
        b.WriteString("\n")

        // Session list (more compact)
        for i, session := range m.sessions </span><span class="cov0" title="0">{
                prefix := "  "
                if i == m.cursor </span><span class="cov0" title="0">{
                        prefix = "‚Üí "
                }</span>

                // Session info
                <span class="cov0" title="0">status := getSessionStatusIndicator(session)
                activity := FormatActivity(session.LastActivity)

                line := fmt.Sprintf("%s%s %s (%s)",
                        prefix,
                        session.Core.Name,
                        status,
                        activity)

                // Style based on selection (less intrusive highlighting)
                if i == m.cursor </span><span class="cov0" title="0">{
                        selectedStyle := lipgloss.NewStyle().
                                Bold(true).
                                Foreground(lipgloss.Color("cyan"))
                        line = selectedStyle.Render(line)
                }</span>

                <span class="cov0" title="0">b.WriteString(line)
                b.WriteString("\n")</span>
        }

        // Compact instructions
        <span class="cov0" title="0">instructionStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                Italic(true)

        instructions := "‚Üë/‚Üì: navigate ‚Ä¢ enter: select ‚Ä¢ q/esc: cancel"
        b.WriteString(instructionStyle.Render(instructions))

        // Show what will be selected for clarity
        if m.selected </span><span class="cov0" title="0">{
                b.WriteString("\n\n‚úì Selected: " + m.sessions[m.cursor].Core.Name)
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

// getSessionStatusIndicator returns a compact status indicator for a session
func getSessionStatusIndicator(session types.Session) string <span class="cov0" title="0">{
        var indicators []string

        // Tmux status
        if session.IsAlive </span><span class="cov0" title="0">{
                indicators = append(indicators, "üü¢")
        }</span> else<span class="cov0" title="0"> {
                indicators = append(indicators, "üî¥")
        }</span>

        // Claude status
        <span class="cov0" title="0">switch session.ClaudeStatus.State </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                indicators = append(indicators, "üîÑ")</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                indicators = append(indicators, "‚è∏Ô∏è")</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                indicators = append(indicators, "‚úÖ")</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                indicators = append(indicators, "üí§")</span>
        default:<span class="cov0" title="0">
                indicators = append(indicators, "‚ùì")</span>
        }

        // Git status
        <span class="cov0" title="0">if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                total := len(session.GitStatus.ModifiedFiles) + len(session.GitStatus.AddedFiles) +
                        len(session.GitStatus.DeletedFiles) + len(session.GitStatus.UntrackedFiles)
                indicators = append(indicators, fmt.Sprintf("üìù%d", total))
        }</span> else<span class="cov0" title="0"> {
                indicators = append(indicators, "‚ú®")
        }</span>

        <span class="cov0" title="0">return strings.Join(indicators, " ")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cli

import (
        "fmt"
        "os"
        "os/exec"
        "sort"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// newStatusCmd creates the 'cwt status' command
func newStatusCmd() *cobra.Command <span class="cov8" title="1">{
        var summary bool
        var branch bool

        cmd := &amp;cobra.Command{
                Use:   "status",
                Short: "Show comprehensive status of all sessions with change details",
                Long: `Show comprehensive view of changes across all sessions with rich status information.

This command provides detailed information about:
- Session states and activity
- Git changes and commit counts  
- Branch relationships and merge status
- Overall project health

Examples:
  cwt status               # Detailed status for all sessions
  cwt status --summary     # Summary view with statistics
  cwt status --branch      # Include branch relationship info`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sm, err := createStateManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer sm.Close()

                        return showEnhancedStatus(sm, summary, branch)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;summary, "summary", false, "Show summary of all changes across sessions")
        cmd.Flags().BoolVar(&amp;branch, "branch", false, "Include branch relationship information")

        return cmd</span>
}

// showEnhancedStatus displays comprehensive session status
func showEnhancedStatus(sm *state.Manager, summary, showBranch bool) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions found.")
                fmt.Println("\nCreate a new session with: cwt new [session-name] [task-description]")
                return nil
        }</span>

        // Sort sessions by last activity (most recent first)
        <span class="cov0" title="0">sort.Slice(sessions, func(i, j int) bool </span><span class="cov0" title="0">{
                return sessions[i].LastActivity.After(sessions[j].LastActivity)
        }</span>)

        <span class="cov0" title="0">if summary </span><span class="cov0" title="0">{
                return showStatusSummary(sessions)
        }</span>

        <span class="cov0" title="0">return showDetailedStatus(sessions, showBranch)</span>
}

// showStatusSummary shows a high-level summary of all sessions
func showStatusSummary(sessions []types.Session) error <span class="cov0" title="0">{
        fmt.Println("üìä Session Summary")
        fmt.Println(strings.Repeat("=", 50))

        // Calculate statistics
        var alive, dead, hasChanges, published, merged int
        var totalModified, totalAdded, totalDeleted int

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.IsAlive </span><span class="cov0" title="0">{
                        alive++
                }</span> else<span class="cov0" title="0"> {
                        dead++
                }</span>

                <span class="cov0" title="0">if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                        hasChanges++
                        totalModified += len(session.GitStatus.ModifiedFiles)
                        totalAdded += len(session.GitStatus.AddedFiles)
                        totalDeleted += len(session.GitStatus.DeletedFiles)
                }</span>

                // Check if published (has remote tracking)
                <span class="cov0" title="0">if isSessionPublished(session) </span><span class="cov0" title="0">{
                        published++
                }</span>

                // Check if merged (would need additional logic)
                <span class="cov0" title="0">if isSessionMerged(session) </span><span class="cov0" title="0">{
                        merged++
                }</span>
        }

        // Display statistics
        <span class="cov0" title="0">fmt.Printf("Total Sessions:    %d\n", len(sessions))
        fmt.Printf("  ‚Ä¢ Active:        %d\n", alive)
        fmt.Printf("  ‚Ä¢ Inactive:      %d\n", dead)
        fmt.Printf("\n")
        fmt.Printf("Change Summary:\n")
        fmt.Printf("  ‚Ä¢ With Changes:  %d\n", hasChanges)
        fmt.Printf("  ‚Ä¢ Clean:         %d\n", len(sessions)-hasChanges)
        fmt.Printf("  ‚Ä¢ Published:     %d\n", published)
        fmt.Printf("  ‚Ä¢ Merged:        %d\n", merged)
        fmt.Printf("\n")
        fmt.Printf("File Changes:\n")
        fmt.Printf("  ‚Ä¢ Modified:      %d\n", totalModified)
        fmt.Printf("  ‚Ä¢ Added:         %d\n", totalAdded)
        fmt.Printf("  ‚Ä¢ Deleted:       %d\n", totalDeleted)

        // Show most recent activity
        if len(sessions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n")
                fmt.Printf("Recent Activity:\n")
                for i, session := range sessions </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{ // Show top 3 most recent
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("  ‚Ä¢ %s: %s\n", session.Core.Name, FormatActivity(session.LastActivity))</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// showDetailedStatus shows detailed information for each session
func showDetailedStatus(sessions []types.Session, showBranch bool) error <span class="cov0" title="0">{
        fmt.Printf("üìã Session Status (%d sessions)\n", len(sessions))
        fmt.Println(strings.Repeat("=", 70))

        for i, session := range sessions </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">renderSessionStatus(session, showBranch)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// renderSessionStatus renders detailed status for a single session
func renderSessionStatus(session types.Session, showBranch bool) <span class="cov0" title="0">{
        // Session header
        fmt.Printf("üè∑Ô∏è  %s", session.Core.Name)

        // Show main status indicators
        statusIndicators := []string{}

        if session.IsAlive </span><span class="cov0" title="0">{
                statusIndicators = append(statusIndicators, "üü¢ active")
        }</span> else<span class="cov0" title="0"> {
                statusIndicators = append(statusIndicators, "üî¥ inactive")
        }</span>

        <span class="cov0" title="0">if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                changeCount := len(session.GitStatus.ModifiedFiles) + len(session.GitStatus.AddedFiles) + len(session.GitStatus.DeletedFiles)
                statusIndicators = append(statusIndicators, fmt.Sprintf("üìù %d changes", changeCount))
        }</span> else<span class="cov0" title="0"> {
                statusIndicators = append(statusIndicators, "‚ú® clean")
        }</span>

        <span class="cov0" title="0">if isSessionPublished(session) </span><span class="cov0" title="0">{
                statusIndicators = append(statusIndicators, "üì§ published")
        }</span>

        <span class="cov0" title="0">fmt.Printf(" (%s)\n", strings.Join(statusIndicators, ", "))

        // Show activity timing
        fmt.Printf("   ‚è∞ Last activity: %s\n", FormatActivity(session.LastActivity))

        // Show Claude status
        claudeIcon := getClaudeIcon(session.ClaudeStatus.State)
        fmt.Printf("   %s Claude: %s", claudeIcon, string(session.ClaudeStatus.State))

        if session.ClaudeStatus.StatusMessage != "" </span><span class="cov0" title="0">{
                fmt.Printf(" - %s", session.ClaudeStatus.StatusMessage)
        }</span>

        <span class="cov0" title="0">if !session.ClaudeStatus.LastMessage.IsZero() </span><span class="cov0" title="0">{
                age := time.Since(session.ClaudeStatus.LastMessage)
                fmt.Printf(" (last: %s ago)", FormatDuration(age))
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Show detailed git status
        if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                fmt.Printf("   üìÅ Git changes:\n")

                if len(session.GitStatus.ModifiedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("      üìù Modified: %s\n",
                                formatFileList(session.GitStatus.ModifiedFiles, 3))
                }</span>

                <span class="cov0" title="0">if len(session.GitStatus.AddedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("      ‚ûï Added: %s\n",
                                formatFileList(session.GitStatus.AddedFiles, 3))
                }</span>

                <span class="cov0" title="0">if len(session.GitStatus.DeletedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("      ‚ûñ Deleted: %s\n",
                                formatFileList(session.GitStatus.DeletedFiles, 3))
                }</span>

                <span class="cov0" title="0">if len(session.GitStatus.UntrackedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("      ‚ùì Untracked: %s\n",
                                formatFileList(session.GitStatus.UntrackedFiles, 3))
                }</span>
        }

        // Show commit count if available
        <span class="cov0" title="0">if session.GitStatus.CommitCount &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("   üìä Commits ahead: %d\n", session.GitStatus.CommitCount)
        }</span>

        // Show branch information if requested
        <span class="cov0" title="0">if showBranch </span><span class="cov0" title="0">{
                branchName := fmt.Sprintf("cwt-%s", session.Core.Name)
                if branchInfo := getBranchInfo(session.Core.WorktreePath, branchName); branchInfo != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   üåø Branch: %s\n", branchInfo)
                }</span>
        }

        // Show path for easy access
        <span class="cov0" title="0">fmt.Printf("   üìÇ Path: %s\n", session.Core.WorktreePath)</span>
}

// Helper functions

func getClaudeIcon(state types.ClaudeState) string <span class="cov0" title="0">{
        switch state </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                return "üîÑ"</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                return "‚è∏Ô∏è"</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                return "‚úÖ"</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                return "üí§"</span>
        default:<span class="cov0" title="0">
                return "‚ùì"</span>
        }
}

func formatFileList(files []string, maxShow int) string <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(files) &lt;= maxShow </span><span class="cov0" title="0">{
                return strings.Join(files, ", ")
        }</span>

        <span class="cov0" title="0">shown := files[:maxShow]
        remaining := len(files) - maxShow
        return fmt.Sprintf("%s... (+%d more)", strings.Join(shown, ", "), remaining)</span>
}

func isSessionPublished(session types.Session) bool <span class="cov0" title="0">{
        // This is a simplified check - in a full implementation,
        // you'd check if the branch has been pushed to remote
        branchName := fmt.Sprintf("cwt-%s", session.Core.Name)

        // Change to worktree directory to check remote tracking
        originalDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer os.Chdir(originalDir)

        if err := os.Chdir(session.Core.WorktreePath); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if branch has remote tracking
        <span class="cov0" title="0">cmd := exec.Command("git", "rev-parse", "--abbrev-ref", fmt.Sprintf("%s@{upstream}", branchName))
        return cmd.Run() == nil</span>
}

func isSessionMerged(session types.Session) bool <span class="cov0" title="0">{
        // This is a simplified check - in a full implementation,
        // you'd check if the session branch has been merged into main
        return false // Placeholder for now
}</span>

func getBranchInfo(worktreePath, branchName string) string <span class="cov0" title="0">{
        // Change to worktree directory
        originalDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">defer os.Chdir(originalDir)

        if err := os.Chdir(worktreePath); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Get branch status relative to main
        <span class="cov0" title="0">cmd := exec.Command("git", "rev-list", "--count", "--left-right", "main..."+branchName)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return branchName
        }</span>

        <span class="cov0" title="0">parts := strings.Fields(strings.TrimSpace(string(output)))
        if len(parts) == 2 </span><span class="cov0" title="0">{
                behind := parts[0]
                ahead := parts[1]
                return fmt.Sprintf("%s (‚Üì%s ‚Üë%s)", branchName, behind, ahead)
        }</span>

        <span class="cov0" title="0">return branchName</span>
}

// Helper functions are imported from list.go - removed duplicates
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// newSwitchCmd creates the 'cwt switch' command
func newSwitchCmd() *cobra.Command <span class="cov8" title="1">{
        var back bool

        cmd := &amp;cobra.Command{
                Use:   "switch [session-name]",
                Short: "Switch to a session's branch for testing or manual work",
                Long: `Switch your main workspace to a session's branch temporarily.
This allows you to test changes or do manual work on the session branch.

Examples:
  cwt switch my-session     # Switch to my-session branch
  cwt switch --back         # Return to previous branch
  cwt switch                # Interactive session selector`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sm, err := createStateManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer sm.Close()

                        if back </span><span class="cov0" title="0">{
                                return switchBack()
                        }</span>

                        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                                return interactiveSwitch(sm)
                        }</span>

                        <span class="cov0" title="0">sessionName := args[0]
                        return switchToSession(sm, sessionName)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;back, "back", false, "Return to previous branch")

        return cmd</span>
}

// switchToSession switches to a session's branch
func switchToSession(sm *state.Manager, sessionName string) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        // Find the session
        <span class="cov0" title="0">var targetSession *types.Session
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.Core.Name == sessionName </span><span class="cov0" title="0">{
                        targetSession = &amp;session
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetSession == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session '%s' not found", sessionName)
        }</span>

        // Get current branch
        <span class="cov0" title="0">currentBranch, err := getCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current branch: %w", err)
        }</span>

        // Check for uncommitted changes and handle them interactively
        <span class="cov0" title="0">if hasUncommittedChanges() </span><span class="cov0" title="0">{
                if err := handleUncommittedChanges(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Save current branch for --back functionality
        <span class="cov0" title="0">if err := savePreviousBranch(currentBranch); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to save previous branch: %v\n", err)
        }</span>

        // Switch to session branch
        <span class="cov0" title="0">sessionBranch := fmt.Sprintf("cwt-%s", sessionName)
        if err := switchBranch(sessionBranch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to switch to branch '%s': %w", sessionBranch, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Switched to session branch: %s\n", sessionBranch)
        fmt.Printf("Use 'cwt switch --back' to return to %s\n", currentBranch)

        return nil</span>
}

// switchBack returns to the previous branch
func switchBack() error <span class="cov0" title="0">{
        previousBranch, err := loadPreviousBranch()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no previous branch saved: %w", err)
        }</span>

        // Check for uncommitted changes
        <span class="cov0" title="0">if hasUncommittedChanges() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot switch: you have uncommitted changes. Please commit or stash them first")
        }</span>

        <span class="cov0" title="0">if err := switchBranch(previousBranch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to switch back to '%s': %w", previousBranch, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Switched back to: %s\n", previousBranch)

        // Clear the saved previous branch
        if err := clearPreviousBranch(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to clear previous branch: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// interactiveSwitch provides an interactive session selector
func interactiveSwitch(sm *state.Manager) error <span class="cov0" title="0">{
        sessions, err := sm.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No sessions available to switch to")
                return nil
        }</span>

        <span class="cov0" title="0">selectedSession, err := SelectSession(sessions, WithTitle("Select a session to switch to:"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to select session: %w", err)
        }</span>

        <span class="cov0" title="0">if selectedSession == nil </span><span class="cov0" title="0">{
                fmt.Println("Cancelled")
                return nil
        }</span>

        <span class="cov0" title="0">return switchToSession(sm, selectedSession.Core.Name)</span>
}

// Helper functions for git operations

func getCurrentBranch() (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", "branch", "--show-current")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

func hasUncommittedChanges() bool <span class="cov0" title="0">{
        cmd := exec.Command("git", "status", "--porcelain")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false // Assume no changes if we can't check
        }</span>
        <span class="cov0" title="0">return len(strings.TrimSpace(string(output))) &gt; 0</span>
}

func switchBranch(branch string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", "checkout", branch)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

// Helper functions for previous branch management

func savePreviousBranch(branch string) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        dataDir := sm.GetDataDir()
        previousBranchFile := filepath.Join(dataDir, "previous_branch")

        // Ensure data directory exists
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(previousBranchFile, []byte(branch), 0644)</span>
}

func loadPreviousBranch() (string, error) <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        dataDir := sm.GetDataDir()
        previousBranchFile := filepath.Join(dataDir, "previous_branch")

        data, err := os.ReadFile(previousBranchFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(data)), nil</span>
}

func clearPreviousBranch() error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sm.Close()

        dataDir := sm.GetDataDir()
        previousBranchFile := filepath.Join(dataDir, "previous_branch")

        return os.Remove(previousBranchFile)</span>
}

// handleUncommittedChanges provides options for dealing with uncommitted changes
func handleUncommittedChanges() error <span class="cov0" title="0">{
        fmt.Println("‚ö†Ô∏è  You have uncommitted changes that need to be handled before switching branches.")
        fmt.Println()

        // Show what changes exist
        if err := showUncommittedChanges(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to show changes: %v\n", err)
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("How would you like to handle these changes?")
        fmt.Println("  1. üì¶ Stash changes (recommended - easily recoverable)")
        fmt.Println("  2. üíæ Commit changes (permanent)")
        fmt.Println("  3. ‚ùå Cancel switch")
        fmt.Println()

        for </span><span class="cov0" title="0">{
                fmt.Print("Enter your choice (1-3) [1]: ")

                var input string
                fmt.Scanln(&amp;input)

                // Default to stash if no input
                if input == "" </span><span class="cov0" title="0">{
                        input = "1"
                }</span>

                <span class="cov0" title="0">switch input </span>{
                case "1":<span class="cov0" title="0">
                        return stashChanges()</span>
                case "2":<span class="cov0" title="0">
                        return commitChanges()</span>
                case "3":<span class="cov0" title="0">
                        return fmt.Errorf("switch cancelled by user")</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Invalid choice. Please enter 1, 2, or 3.")
                        continue</span>
                }
        }
}

// showUncommittedChanges displays what changes exist
func showUncommittedChanges() error <span class="cov0" title="0">{
        cmd := exec.Command("git", "status", "--short")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(output) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Changes that will be affected:")
                lines := strings.Split(strings.TrimSpace(string(output)), "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        if line != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  %s\n", line)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// stashChanges stashes the current changes
func stashChanges() error <span class="cov0" title="0">{
        fmt.Println("üì¶ Stashing changes...")

        // Create a meaningful stash message
        timestamp := time.Now().Format("2006-01-02 15:04:05")
        message := fmt.Sprintf("CWT auto-stash before branch switch - %s", timestamp)

        cmd := exec.Command("git", "stash", "push", "-m", message)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stash changes: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Changes stashed successfully!")
        fmt.Println("üí° Use 'git stash pop' to restore them later")
        return nil</span>
}

// commitChanges prompts for a commit message and commits changes
func commitChanges() error <span class="cov0" title="0">{
        fmt.Print("Enter commit message: ")

        reader := bufio.NewReader(os.Stdin)
        message, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read commit message: %w", err)
        }</span>

        <span class="cov0" title="0">message = strings.TrimSpace(message)
        if message == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("commit message cannot be empty")
        }</span>

        <span class="cov0" title="0">fmt.Println("üíæ Committing changes...")

        // Add all changes
        if err := exec.Command("git", "add", ".").Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stage changes: %w", err)
        }</span>

        // Commit changes
        <span class="cov0" title="0">cmd := exec.Command("git", "commit", "-m", message)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit changes: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Changes committed successfully!")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"

        "github.com/jlaneve/cwt-cli/internal/tui"
)

func newTuiCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "tui",
                Short: "Launch the interactive TUI dashboard",
                Long: `Launch the TUI (Terminal User Interface) dashboard for CWT.

The TUI provides:
- Real-time session status monitoring
- Interactive session management
- Visual indicators for tmux, git, and Claude status
- Quick session creation and deletion
- Session attachment capabilities`,
                Aliases: []string{"ui", "dashboard"},
                RunE:    runTuiCmd,
        }

        return cmd
}</span>

func runTuiCmd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        sm, err := createStateManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Note: StateManager will be closed by the TUI when it exits

        // Launch TUI
        <span class="cov0" title="0">if err := tui.Run(sm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("TUI error: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package claude

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/jlaneve/cwt-cli/internal/clients/tmux"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// Checker defines the interface for Claude status operations
type Checker interface {
        GetStatus(worktreePath string) types.ClaudeStatus
        FindSessionID(worktreePath string) (string, error)
}

// RealChecker implements Checker using actual Claude session detection
type RealChecker struct {
        tmuxChecker tmux.Checker
        scanner     *SessionScanner
}

// NewRealChecker creates a new RealChecker
func NewRealChecker(tmuxChecker tmux.Checker) *RealChecker <span class="cov0" title="0">{
        return &amp;RealChecker{
                tmuxChecker: tmuxChecker,
                scanner:     NewSessionScanner(),
        }
}</span>

// GetStatus analyzes Claude activity in a worktree
func (r *RealChecker) GetStatus(worktreePath string) types.ClaudeStatus <span class="cov0" title="0">{
        status := types.ClaudeStatus{
                State:        types.ClaudeUnknown,
                Availability: types.AvailVeryStale,
        }

        // Use scanner to find the most recent Claude session
        claudeSession, err := r.scanner.GetMostRecentSession(worktreePath)
        if err != nil || claudeSession == nil </span><span class="cov0" title="0">{
                return status
        }</span>

        <span class="cov0" title="0">status.SessionID = claudeSession.SessionID
        status.LastMessage = claudeSession.LastSeen

        // Parse last message from JSONL file
        lastMessage, err := r.parseLastMessage(claudeSession.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to session metadata if JSONL parsing fails
                status.LastMessage = claudeSession.LastSeen
                status.Availability = r.calculateAvailability(claudeSession.LastSeen)
                return status
        }</span>

        // Update timestamp from parsed message
        <span class="cov0" title="0">status.LastMessage = lastMessage.Timestamp

        // Determine state from message content
        status.State = r.determineStateFromMessage(lastMessage)

        // Check tmux for waiting prompts (overrides JSONL state)
        if status.State == types.ClaudeWorking </span><span class="cov0" title="0">{
                tmuxSession := r.deriveTmuxSessionName(worktreePath)
                if r.checkTmuxForWaitingPrompt(tmuxSession) </span><span class="cov0" title="0">{
                        status.State = types.ClaudeWaiting
                }</span>
        }

        // Calculate availability from timestamp
        <span class="cov0" title="0">status.Availability = r.calculateAvailability(lastMessage.Timestamp)

        return status</span>
}

// FindSessionID finds the Claude session ID for a worktree
func (r *RealChecker) FindSessionID(worktreePath string) (string, error) <span class="cov0" title="0">{
        // Use scanner to find session
        claudeSession, err := r.scanner.GetMostRecentSession(worktreePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if claudeSession == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no Claude session found for worktree %s", worktreePath)
        }</span>

        <span class="cov0" title="0">return claudeSession.SessionID, nil</span>
}

func (r *RealChecker) parseLastMessage(jsonlPath string) (types.ClaudeMessage, error) <span class="cov0" title="0">{
        file, err := os.Open(jsonlPath)
        if err != nil </span><span class="cov0" title="0">{
                return types.ClaudeMessage{}, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var lastMessage types.ClaudeMessage
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var rawMessage map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;rawMessage); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse message structure
                <span class="cov0" title="0">if msg, ok := rawMessage["message"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        claudeMsg := types.ClaudeMessage{}

                        if role, ok := msg["role"].(string); ok </span><span class="cov0" title="0">{
                                claudeMsg.Role = role
                        }</span>

                        <span class="cov0" title="0">if content, ok := msg["content"].([]interface{}); ok </span><span class="cov0" title="0">{
                                for _, c := range content </span><span class="cov0" title="0">{
                                        if contentMap, ok := c.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                contentItem := types.Content{}
                                                if contentType, ok := contentMap["type"].(string); ok </span><span class="cov0" title="0">{
                                                        contentItem.Type = contentType
                                                }</span>
                                                <span class="cov0" title="0">if text, ok := contentMap["text"].(string); ok </span><span class="cov0" title="0">{
                                                        contentItem.Text = text
                                                }</span>
                                                <span class="cov0" title="0">if name, ok := contentMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                        contentItem.Name = name
                                                }</span>
                                                <span class="cov0" title="0">claudeMsg.Content = append(claudeMsg.Content, contentItem)</span>
                                        }
                                }
                        }

                        // Parse timestamp
                        <span class="cov0" title="0">if timestamp, ok := rawMessage["timestamp"].(string); ok </span><span class="cov0" title="0">{
                                if parsed, err := time.Parse(time.RFC3339, timestamp); err == nil </span><span class="cov0" title="0">{
                                        claudeMsg.Timestamp = parsed
                                }</span>
                        }

                        <span class="cov0" title="0">if claudeMsg.Role == "assistant" </span><span class="cov0" title="0">{
                                lastMessage = claudeMsg
                        }</span>
                }
        }

        <span class="cov0" title="0">if lastMessage.Role == "" </span><span class="cov0" title="0">{
                return types.ClaudeMessage{}, fmt.Errorf("no assistant messages found in JSONL")
        }</span>

        <span class="cov0" title="0">return lastMessage, nil</span>
}

func (r *RealChecker) determineStateFromMessage(message types.ClaudeMessage) types.ClaudeState <span class="cov0" title="0">{
        // Check if message contains tool usage
        for _, content := range message.Content </span><span class="cov0" title="0">{
                if content.Type == "tool_use" </span><span class="cov0" title="0">{
                        return types.ClaudeWorking
                }</span>
        }

        // If no tools, Claude is waiting for user input
        <span class="cov0" title="0">return types.ClaudeWaiting</span>
}

func (r *RealChecker) checkTmuxForWaitingPrompt(tmuxSession string) bool <span class="cov0" title="0">{
        if r.tmuxChecker == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !r.tmuxChecker.IsSessionAlive(tmuxSession) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">output, err := r.tmuxChecker.CaptureOutput(tmuxSession)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for common waiting prompts
        <span class="cov0" title="0">waitingPatterns := []*regexp.Regexp{
                regexp.MustCompile(`Do you want to.*\?`),
                regexp.MustCompile(`\d+\.\s+(Yes|No|Cancel)`),
                regexp.MustCompile(`‚ùØ\s*\d+\.\s+(Yes|No|Cancel)`),
                regexp.MustCompile(`Continue\?\s*\(y/n\)`),
                regexp.MustCompile(`Press.*to continue`),
        }

        for _, pattern := range waitingPatterns </span><span class="cov0" title="0">{
                if pattern.MatchString(output) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (r *RealChecker) deriveTmuxSessionName(worktreePath string) string <span class="cov0" title="0">{
        // Extract session name from worktree path
        // Assumes path like: .cwt/worktrees/{session-name}
        base := filepath.Base(worktreePath)
        return fmt.Sprintf("cwt-%s", base)
}</span>

func (r *RealChecker) calculateAvailability(timestamp time.Time) types.Availability <span class="cov0" title="0">{
        if timestamp.IsZero() </span><span class="cov0" title="0">{
                return types.AvailVeryStale
        }</span>

        <span class="cov0" title="0">age := time.Since(timestamp)

        switch </span>{
        case age &lt; 5*time.Minute:<span class="cov0" title="0">
                return types.AvailCurrent</span>
        case age &lt; 1*time.Hour:<span class="cov0" title="0">
                return types.AvailRecent</span>
        case age &lt; 24*time.Hour:<span class="cov0" title="0">
                return types.AvailStale</span>
        default:<span class="cov0" title="0">
                return types.AvailVeryStale</span>
        }
}

// MockChecker implements Checker for testing
type MockChecker struct {
        Statuses map[string]types.ClaudeStatus
        Delay    time.Duration
}

// NewMockChecker creates a new MockChecker
func NewMockChecker() *MockChecker <span class="cov8" title="1">{
        return &amp;MockChecker{
                Statuses: make(map[string]types.ClaudeStatus),
        }
}</span>

// GetStatus returns the mocked status
func (m *MockChecker) GetStatus(worktreePath string) types.ClaudeStatus <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">status, exists := m.Statuses[worktreePath]
        if !exists </span><span class="cov8" title="1">{
                return types.ClaudeStatus{
                        State:        types.ClaudeUnknown,
                        Availability: types.AvailVeryStale,
                }
        }</span>
        <span class="cov0" title="0">return status</span>
}

// FindSessionID returns a mock session ID
func (m *MockChecker) FindSessionID(worktreePath string) (string, error) <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        // Return a mock session ID based on path
        <span class="cov8" title="1">return fmt.Sprintf("mock-session-%s", filepath.Base(worktreePath)), nil</span>
}

// SetStatus sets the Claude status for testing
func (m *MockChecker) SetStatus(worktreePath string, status types.ClaudeStatus) <span class="cov0" title="0">{
        m.Statuses[worktreePath] = status
}</span>

// SetDelay sets a delay for all operations
func (m *MockChecker) SetDelay(delay time.Duration) <span class="cov0" title="0">{
        m.Delay = delay
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package claude

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

// ClaudeSession represents a Claude Code session from JSONL
type ClaudeSession struct {
        SessionID    string    `json:"sessionId"`
        CWD          string    `json:"cwd"`
        LastSeen     time.Time `json:"lastSeen"`
        FilePath     string    `json:"filePath"`
        MessageCount int       `json:"messageCount"`
}

// SessionScanner discovers Claude Code sessions
type SessionScanner struct {
        claudeDir string
}

// NewSessionScanner creates a new Claude session scanner
func NewSessionScanner() *SessionScanner <span class="cov0" title="0">{
        homeDir, _ := os.UserHomeDir()
        return &amp;SessionScanner{
                claudeDir: filepath.Join(homeDir, ".claude"),
        }
}</span>

// FindSessionsForDirectory finds Claude sessions that match a given directory
func (s *SessionScanner) FindSessionsForDirectory(targetDir string) ([]*ClaudeSession, error) <span class="cov0" title="0">{
        // Convert to absolute path for matching
        absTargetDir, err := filepath.Abs(targetDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        // Build project directory path from target directory
        // Example: /Users/julian/Astronomer/cwt-cli/.cwt/worktrees/test -&gt; -Users-julian-Astronomer-cwt-cli--cwt-worktrees-test
        // Claude converts /.cwt/ to --cwt- (double dash for hidden dirs)
        <span class="cov0" title="0">projectName := strings.ReplaceAll(absTargetDir, "/", "-")
        projectName = strings.ReplaceAll(projectName, "-.cwt-", "--cwt-")
        projectDir := filepath.Join(s.claudeDir, "projects", projectName)

        // Check if project directory exists
        if _, err := os.Stat(projectDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return []*ClaudeSession{}, nil // No Claude sessions for this directory
        }</span>

        // Scan all .jsonl files in the project directory
        <span class="cov0" title="0">files, err := filepath.Glob(filepath.Join(projectDir, "*.jsonl"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan claude sessions: %w", err)
        }</span>

        <span class="cov0" title="0">var sessions []*ClaudeSession
        for _, file := range files </span><span class="cov0" title="0">{
                session, err := s.parseSessionFile(file, absTargetDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip problematic files
                }
                <span class="cov0" title="0">if session != nil </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span>
        }

        // Sort by most recent activity first
        <span class="cov0" title="0">sort.Slice(sessions, func(i, j int) bool </span><span class="cov0" title="0">{
                return sessions[i].LastSeen.After(sessions[j].LastSeen)
        }</span>)

        <span class="cov0" title="0">return sessions, nil</span>
}

// GetMostRecentSession returns the most recently active Claude session for a directory
func (s *SessionScanner) GetMostRecentSession(targetDir string) (*ClaudeSession, error) <span class="cov0" title="0">{
        sessions, err := s.FindSessionsForDirectory(targetDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                return nil, nil // No sessions found
        }</span>

        <span class="cov0" title="0">return sessions[0], nil</span> // Most recent is first due to sorting
}

// parseSessionFile extracts session metadata from a JSONL file
func (s *SessionScanner) parseSessionFile(filePath, targetDir string) (*ClaudeSession, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        var sessionID string
        var cwd string
        var lastSeen time.Time
        var messageCount int

        // Read each line of JSONL
        for scanner.Scan() </span><span class="cov0" title="0">{
                var line map[string]interface{}
                if err := json.Unmarshal(scanner.Bytes(), &amp;line); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid JSON lines
                }

                // Extract session metadata from first message
                <span class="cov0" title="0">if sessionID == "" </span><span class="cov0" title="0">{
                        if sid, ok := line["sessionId"].(string); ok </span><span class="cov0" title="0">{
                                sessionID = sid
                        }</span>
                        <span class="cov0" title="0">if c, ok := line["cwd"].(string); ok </span><span class="cov0" title="0">{
                                cwd = c
                        }</span>
                }

                // Track last activity timestamp
                <span class="cov0" title="0">if timestampStr, ok := line["timestamp"].(string); ok </span><span class="cov0" title="0">{
                        if t, err := time.Parse(time.RFC3339, timestampStr); err == nil </span><span class="cov0" title="0">{
                                if t.After(lastSeen) </span><span class="cov0" title="0">{
                                        lastSeen = t
                                }</span>
                        }
                }

                <span class="cov0" title="0">messageCount++</span>
        }

        // Only return session if it matches our target directory exactly
        <span class="cov0" title="0">if cwd != targetDir </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Must have valid session ID and recent activity
        <span class="cov0" title="0">if sessionID == "" || lastSeen.IsZero() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;ClaudeSession{
                SessionID:    sessionID,
                CWD:          cwd,
                LastSeen:     lastSeen,
                FilePath:     filePath,
                MessageCount: messageCount,
        }, nil</span>
}

// IsClaudeAvailable checks if claude command is available
func (s *SessionScanner) IsClaudeAvailable() bool <span class="cov0" title="0">{
        // Check common installation paths
        claudePaths := []string{
                "/usr/local/bin/claude",
                os.ExpandEnv("$HOME/.claude/local/claude"),
                os.ExpandEnv("$HOME/.claude/local/node_modules/.bin/claude"),
        }

        for _, path := range claudePaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package git

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// Checker defines the interface for git operations
type Checker interface {
        GetStatus(worktreePath string) types.GitStatus
        CreateWorktree(branchName, worktreePath string) error
        RemoveWorktree(worktreePath string) error
        IsValidRepository(repoPath string) error
        ListWorktrees() ([]WorktreeInfo, error)
        BranchExists(branchName string) bool
        CommitChanges(worktreePath, message string) error
        CheckoutBranch(branchName string) error
}

// WorktreeInfo represents information about a git worktree
type WorktreeInfo struct {
        Path   string
        Branch string
        Bare   bool
}

// RealChecker implements Checker using actual git commands
type RealChecker struct {
        BaseBranch string // Default branch to create worktrees from
}

// NewRealChecker creates a new RealChecker
func NewRealChecker(baseBranch string) *RealChecker <span class="cov0" title="0">{
        if baseBranch == "" </span><span class="cov0" title="0">{
                baseBranch = "main"
        }</span>
        <span class="cov0" title="0">return &amp;RealChecker{BaseBranch: baseBranch}</span>
}

// GetStatus checks the git status of a worktree
func (r *RealChecker) GetStatus(worktreePath string) types.GitStatus <span class="cov0" title="0">{
        status := types.GitStatus{}

        if !r.pathExists(worktreePath) </span><span class="cov0" title="0">{
                return status
        }</span>

        // Get porcelain status
        <span class="cov0" title="0">cmd := exec.Command("git", "status", "--porcelain")
        cmd.Dir = worktreePath
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return status
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimRight(string(output), "\n"), "\n")
        if len(lines) == 1 &amp;&amp; lines[0] == "" </span><span class="cov0" title="0">{
                // No changes
                return status
        }</span>

        <span class="cov0" title="0">for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">statusCode := line[:2]
                filename := line[3:]

                // Ignore Claude-related files and directories
                if strings.HasPrefix(filename, ".claude/") || filename == ".claude" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // We have a non-Claude change
                <span class="cov0" title="0">status.HasChanges = true

                switch </span>{
                case strings.HasPrefix(statusCode, "M") || strings.HasPrefix(statusCode, " M"):<span class="cov0" title="0">
                        status.ModifiedFiles = append(status.ModifiedFiles, filename)</span>
                case strings.HasPrefix(statusCode, "A"):<span class="cov0" title="0">
                        status.AddedFiles = append(status.AddedFiles, filename)</span>
                case strings.HasPrefix(statusCode, "??"):<span class="cov0" title="0">
                        status.UntrackedFiles = append(status.UntrackedFiles, filename)</span>
                case strings.HasPrefix(statusCode, "D") || strings.HasPrefix(statusCode, " D"):<span class="cov0" title="0">
                        status.DeletedFiles = append(status.DeletedFiles, filename)</span>
                }
        }

        // Count commits ahead of base branch
        <span class="cov0" title="0">cmd = exec.Command("git", "rev-list", "--count", fmt.Sprintf("%s..HEAD", r.BaseBranch))
        cmd.Dir = worktreePath
        output, err = cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                fmt.Sscanf(string(output), "%d", &amp;status.CommitCount)
        }</span>

        <span class="cov0" title="0">return status</span>
}

// CreateWorktree creates a new git worktree with a new branch
func (r *RealChecker) CreateWorktree(branchName, worktreePath string) error <span class="cov0" title="0">{
        // Check if worktree directory already exists
        if r.pathExists(worktreePath) </span><span class="cov0" title="0">{
                return fmt.Errorf("worktree directory already exists: %s", worktreePath)
        }</span>

        // Check if branch already exists
        <span class="cov0" title="0">if r.BranchExists(branchName) </span><span class="cov0" title="0">{
                return fmt.Errorf("branch '%s' already exists. Please use a different session name or delete the existing branch with: git branch -d %s", branchName, branchName)
        }</span>

        // Ensure parent directory exists
        <span class="cov0" title="0">parentDir := filepath.Dir(worktreePath)
        if err := os.MkdirAll(parentDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directory %s: %w", parentDir, err)
        }</span>

        // Create worktree with new branch
        <span class="cov0" title="0">cmd := exec.Command("git", "worktree", "add", "-b", branchName, worktreePath, r.BaseBranch)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create worktree %s: %w\nOutput: %s", worktreePath, err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveWorktree removes a git worktree
func (r *RealChecker) RemoveWorktree(worktreePath string) error <span class="cov0" title="0">{
        // Remove the worktree
        cmd := exec.Command("git", "worktree", "remove", worktreePath, "--force")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove worktree %s: %w\nOutput: %s", worktreePath, err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsValidRepository checks if the current directory is a valid git repository
func (r *RealChecker) IsValidRepository(repoPath string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "--git-dir")
        if repoPath != "" </span><span class="cov0" title="0">{
                cmd.Dir = repoPath
        }</span>
        <span class="cov0" title="0">err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not a git repository: %w", err)
        }</span>

        // Check if repository has commits
        <span class="cov0" title="0">cmd = exec.Command("git", "rev-parse", "HEAD")
        if repoPath != "" </span><span class="cov0" title="0">{
                cmd.Dir = repoPath
        }</span>
        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("repository has no commits: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListWorktrees returns all git worktrees
func (r *RealChecker) ListWorktrees() ([]WorktreeInfo, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", "worktree", "list", "--porcelain")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list worktrees: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        var worktrees []WorktreeInfo
        var current WorktreeInfo

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        if current.Path != "" </span><span class="cov0" title="0">{
                                worktrees = append(worktrees, current)
                                current = WorktreeInfo{}
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if strings.HasPrefix(line, "worktree ") </span><span class="cov0" title="0">{
                        current.Path = strings.TrimPrefix(line, "worktree ")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "branch ") </span><span class="cov0" title="0">{
                        current.Branch = strings.TrimPrefix(line, "branch ")
                }</span> else<span class="cov0" title="0"> if line == "bare" </span><span class="cov0" title="0">{
                        current.Bare = true
                }</span>
        }

        // Add final worktree if exists
        <span class="cov0" title="0">if current.Path != "" </span><span class="cov0" title="0">{
                worktrees = append(worktrees, current)
        }</span>

        <span class="cov0" title="0">return worktrees, nil</span>
}

func (r *RealChecker) pathExists(path string) bool <span class="cov0" title="0">{
        _, err := os.Stat(path)
        return err == nil
}</span>

// BranchExists checks if a git branch exists (local or remote)
func (r *RealChecker) BranchExists(branchName string) bool <span class="cov0" title="0">{
        // Check local branches first
        cmd := exec.Command("git", "branch", "--list", branchName)
        output, err := cmd.Output()
        if err == nil &amp;&amp; strings.TrimSpace(string(output)) != "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check remote branches
        <span class="cov0" title="0">cmd = exec.Command("git", "branch", "-r", "--list", "*"+branchName)
        output, err = cmd.Output()
        if err == nil &amp;&amp; strings.TrimSpace(string(output)) != "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// CommitChanges stages all changes and commits them with the given message
func (r *RealChecker) CommitChanges(worktreePath, message string) error <span class="cov0" title="0">{
        // Stage all changes
        cmd := exec.Command("git", "add", ".")
        cmd.Dir = worktreePath
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stage changes: %w\nOutput: %s", err, string(output))
        }</span>

        // Get git user configuration
        <span class="cov0" title="0">name, email := r.getGitUserConfig()

        // Create commit
        cmd = exec.Command("git", "commit", "-m", message)
        if name != "" </span><span class="cov0" title="0">{
                cmd.Env = append(os.Environ(), fmt.Sprintf("GIT_AUTHOR_NAME=%s", name))
                cmd.Env = append(cmd.Env, fmt.Sprintf("GIT_COMMITTER_NAME=%s", name))
        }</span>
        <span class="cov0" title="0">if email != "" </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, fmt.Sprintf("GIT_AUTHOR_EMAIL=%s", email))
                cmd.Env = append(cmd.Env, fmt.Sprintf("GIT_COMMITTER_EMAIL=%s", email))
        }</span>
        <span class="cov0" title="0">cmd.Dir = worktreePath
        output, err = cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit changes: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CheckoutBranch switches to the specified branch
func (r *RealChecker) CheckoutBranch(branchName string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", "checkout", branchName)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to checkout branch %s: %w\nOutput: %s", branchName, err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// getGitUserConfig gets the git user name and email from config
func (r *RealChecker) getGitUserConfig() (string, string) <span class="cov0" title="0">{
        var name, email string

        // Get user name
        cmd := exec.Command("git", "config", "user.name")
        if output, err := cmd.Output(); err == nil </span><span class="cov0" title="0">{
                name = strings.TrimSpace(string(output))
        }</span>

        // Get user email
        <span class="cov0" title="0">cmd = exec.Command("git", "config", "user.email")
        if output, err := cmd.Output(); err == nil </span><span class="cov0" title="0">{
                email = strings.TrimSpace(string(output))
        }</span>

        // Fallback values if not configured
        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                name = "CWT User"
        }</span>
        <span class="cov0" title="0">if email == "" </span><span class="cov0" title="0">{
                email = "user@example.com"
        }</span>

        <span class="cov0" title="0">return name, email</span>
}

// MockChecker implements Checker for testing
type MockChecker struct {
        Statuses   map[string]types.GitStatus
        Worktrees  map[string]bool
        ShouldFail map[string]bool
        Delay      time.Duration
        ValidRepo  bool
}

// NewMockChecker creates a new MockChecker
func NewMockChecker() *MockChecker <span class="cov8" title="1">{
        return &amp;MockChecker{
                Statuses:   make(map[string]types.GitStatus),
                Worktrees:  make(map[string]bool),
                ShouldFail: make(map[string]bool),
                ValidRepo:  true,
        }
}</span>

// GetStatus returns the mocked status
func (m *MockChecker) GetStatus(worktreePath string) types.GitStatus <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">status, exists := m.Statuses[worktreePath]
        if !exists </span><span class="cov8" title="1">{
                return types.GitStatus{} // Empty status
        }</span>
        <span class="cov0" title="0">return status</span>
}

// CreateWorktree mocks worktree creation
func (m *MockChecker) CreateWorktree(branchName, worktreePath string) error <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">if m.ShouldFail[worktreePath] </span><span class="cov0" title="0">{
                return fmt.Errorf("mock create failure for worktree %s", worktreePath)
        }</span>
        <span class="cov8" title="1">m.Worktrees[worktreePath] = true
        return nil</span>
}

// RemoveWorktree mocks worktree removal
func (m *MockChecker) RemoveWorktree(worktreePath string) error <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">if m.ShouldFail[worktreePath] </span><span class="cov0" title="0">{
                return fmt.Errorf("mock remove failure for worktree %s", worktreePath)
        }</span>
        <span class="cov8" title="1">delete(m.Worktrees, worktreePath)
        return nil</span>
}

// IsValidRepository returns the mocked validity
func (m *MockChecker) IsValidRepository(repoPath string) error <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">if !m.ValidRepo </span><span class="cov0" title="0">{
                return fmt.Errorf("mock repository validation failure")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListWorktrees returns mocked worktree list
func (m *MockChecker) ListWorktrees() ([]WorktreeInfo, error) <span class="cov0" title="0">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov0" title="0">var worktrees []WorktreeInfo
        for path := range m.Worktrees </span><span class="cov0" title="0">{
                worktrees = append(worktrees, WorktreeInfo{
                        Path:   path,
                        Branch: filepath.Base(path),
                })
        }</span>
        <span class="cov0" title="0">return worktrees, nil</span>
}

// SetStatus sets the git status for testing
func (m *MockChecker) SetStatus(worktreePath string, status types.GitStatus) <span class="cov0" title="0">{
        m.Statuses[worktreePath] = status
}</span>

// SetWorktreeExists sets whether a worktree exists
func (m *MockChecker) SetWorktreeExists(worktreePath string, exists bool) <span class="cov0" title="0">{
        if exists </span><span class="cov0" title="0">{
                m.Worktrees[worktreePath] = true
        }</span> else<span class="cov0" title="0"> {
                delete(m.Worktrees, worktreePath)
        }</span>
}

// SetShouldFail sets whether operations should fail
func (m *MockChecker) SetShouldFail(worktreePath string, shouldFail bool) <span class="cov0" title="0">{
        m.ShouldFail[worktreePath] = shouldFail
}</span>

// SetDelay sets a delay for all operations
func (m *MockChecker) SetDelay(delay time.Duration) <span class="cov0" title="0">{
        m.Delay = delay
}</span>

// BranchExists returns whether a branch exists (always false for mock)
func (m *MockChecker) BranchExists(branchName string) bool <span class="cov0" title="0">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        // Mock implementation - can be configured if needed
        <span class="cov0" title="0">return false</span>
}

// CommitChanges mocks committing changes
func (m *MockChecker) CommitChanges(worktreePath, message string) error <span class="cov0" title="0">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov0" title="0">if m.ShouldFail[worktreePath] </span><span class="cov0" title="0">{
                return fmt.Errorf("mock commit failure for worktree %s", worktreePath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckoutBranch mocks checking out a branch
func (m *MockChecker) CheckoutBranch(branchName string) error <span class="cov0" title="0">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        // Mock implementation - always succeeds unless configured otherwise
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package tmux

import (
        "fmt"
        "os/exec"
        "strings"
        "time"
)

// Checker defines the interface for tmux operations
type Checker interface {
        IsSessionAlive(sessionName string) bool
        CaptureOutput(sessionName string) (string, error)
        CreateSession(name, workdir, command string) error
        KillSession(sessionName string) error
        ListSessions() ([]string, error)
}

// RealChecker implements Checker using actual tmux commands
type RealChecker struct{}

// NewRealChecker creates a new RealChecker
func NewRealChecker() *RealChecker <span class="cov8" title="1">{
        return &amp;RealChecker{}
}</span>

// IsSessionAlive checks if a tmux session exists and is running
func (r *RealChecker) IsSessionAlive(sessionName string) bool <span class="cov8" title="1">{
        cmd := exec.Command("tmux", "has-session", "-t", sessionName)
        err := cmd.Run()
        return err == nil
}</span>

// CaptureOutput captures the current pane output from a tmux session
func (r *RealChecker) CaptureOutput(sessionName string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("tmux", "capture-pane", "-t", sessionName, "-p")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to capture tmux output for session %s: %w", sessionName, err)
        }</span>
        <span class="cov0" title="0">return string(output), nil</span>
}

// CreateSession creates a new tmux session with the specified command
func (r *RealChecker) CreateSession(name, workdir, command string) error <span class="cov0" title="0">{
        args := []string{
                "new-session",
                "-d",       // detached
                "-s", name, // session name
                "-c", workdir, // working directory
        }

        if command != "" </span><span class="cov0" title="0">{
                args = append(args, command)
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("tmux", args...)
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tmux session %s: %w", name, err)
        }</span>

        // Enable mouse mode for the session to allow scrolling
        <span class="cov0" title="0">mouseCmd := exec.Command("tmux", "set-option", "-t", name, "mouse", "on")
        if err := mouseCmd.Run(); err != nil </span><span class="cov0" title="0">{
                // Non-fatal error - session still usable without mouse mode
                fmt.Printf("Warning: Failed to enable mouse mode for session %s: %v\n", name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// KillSession terminates a tmux session
func (r *RealChecker) KillSession(sessionName string) error <span class="cov0" title="0">{
        cmd := exec.Command("tmux", "kill-session", "-t", sessionName)
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to kill tmux session %s: %w", sessionName, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListSessions returns a list of all active tmux sessions
func (r *RealChecker) ListSessions() ([]string, error) <span class="cov0" title="0">{
        cmd := exec.Command("tmux", "list-sessions", "-F", "#{session_name}")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // tmux returns exit code 1 when no sessions exist
                if exitError, ok := err.(*exec.ExitError); ok &amp;&amp; exitError.ExitCode() == 1 </span><span class="cov0" title="0">{
                        return []string{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to list tmux sessions: %w", err)</span>
        }

        <span class="cov0" title="0">sessions := strings.Split(strings.TrimSpace(string(output)), "\n")
        if len(sessions) == 1 &amp;&amp; sessions[0] == "" </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov0" title="0">return sessions, nil</span>
}

// MockChecker implements Checker for testing
type MockChecker struct {
        AliveSessions    map[string]bool
        Output           map[string]string
        CreatedSessions  []string
        KilledSessions   []string
        ShouldFailCreate bool
        Delay            time.Duration
}

// NewMockChecker creates a new MockChecker
func NewMockChecker() *MockChecker <span class="cov8" title="1">{
        return &amp;MockChecker{
                AliveSessions:   make(map[string]bool),
                Output:          make(map[string]string),
                CreatedSessions: []string{},
                KilledSessions:  []string{},
        }
}</span>

// IsSessionAlive returns the mocked status
func (m *MockChecker) IsSessionAlive(sessionName string) bool <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">return m.AliveSessions[sessionName]</span>
}

// CaptureOutput returns the mocked output
func (m *MockChecker) CaptureOutput(sessionName string) (string, error) <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">output, exists := m.Output[sessionName]
        if !exists </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no output configured for session %s", sessionName)
        }</span>
        <span class="cov8" title="1">return output, nil</span>
}

// CreateSession mocks session creation
func (m *MockChecker) CreateSession(name, workdir, command string) error <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">if m.ShouldFailCreate </span><span class="cov8" title="1">{
                return fmt.Errorf("mock create failure for session %s", name)
        }</span>
        <span class="cov8" title="1">m.CreatedSessions = append(m.CreatedSessions, name)
        m.AliveSessions[name] = true
        return nil</span>
}

// KillSession mocks session termination
func (m *MockChecker) KillSession(sessionName string) error <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">m.KilledSessions = append(m.KilledSessions, sessionName)
        m.AliveSessions[sessionName] = false
        return nil</span>
}

// SetSessionAlive sets the alive status for a session
func (m *MockChecker) SetSessionAlive(sessionName string, alive bool) <span class="cov8" title="1">{
        m.AliveSessions[sessionName] = alive
}</span>

// ListSessions returns all alive sessions
func (m *MockChecker) ListSessions() ([]string, error) <span class="cov8" title="1">{
        if m.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.Delay)
        }</span>
        <span class="cov8" title="1">sessions := make([]string, 0)
        for name, alive := range m.AliveSessions </span><span class="cov8" title="1">{
                if alive </span><span class="cov8" title="1">{
                        sessions = append(sessions, name)
                }</span>
        }
        <span class="cov8" title="1">return sessions, nil</span>
}

// SetAlive sets the alive status for testing
func (m *MockChecker) SetAlive(sessionName string, alive bool) <span class="cov0" title="0">{
        m.AliveSessions[sessionName] = alive
}</span>

// SetOutput sets the output for testing
func (m *MockChecker) SetOutput(sessionName, output string) <span class="cov0" title="0">{
        m.Output[sessionName] = output
}</span>

// SetDelay sets a delay for all operations (for performance testing)
func (m *MockChecker) SetDelay(delay time.Duration) <span class="cov0" title="0">{
        m.Delay = delay
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package events

import (
        "sync"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// Bus provides a simple event bus for publishing and subscribing to events
type Bus struct {
        subscribers []chan types.Event
        mu          sync.RWMutex
}

// NewBus creates a new event bus
func NewBus() *Bus <span class="cov8" title="1">{
        return &amp;Bus{
                subscribers: make([]chan types.Event, 0),
        }
}</span>

// Subscribe returns a channel that will receive all published events
func (b *Bus) Subscribe() &lt;-chan types.Event <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        ch := make(chan types.Event, 100) // Buffered to prevent blocking
        b.subscribers = append(b.subscribers, ch)
        return ch
}</span>

// Publish sends an event to all subscribers
func (b *Bus) Publish(event types.Event) <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        for _, ch := range b.subscribers </span><span class="cov8" title="1">{
                select </span>{
                case ch &lt;- event:<span class="cov8" title="1"></span>
                        // Event sent successfully
                default:<span class="cov8" title="1"></span>
                        // Subscriber channel is full, skip to prevent blocking
                        // In a production system, you might want to log this
                }
        }
}

// Close closes all subscriber channels
func (b *Bus) Close() <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        for _, ch := range b.subscribers </span><span class="cov8" title="1">{
                close(ch)
        }</span>
        <span class="cov8" title="1">b.subscribers = nil</span>
}

// SubscriberCount returns the number of active subscribers
func (b *Bus) SubscriberCount() int <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return len(b.subscribers)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package operations

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/jlaneve/cwt-cli/internal/state"
)

// CleanupStats tracks the results of a cleanup operation
type CleanupStats struct {
        StaleSessions     int
        OrphanedTmux      int
        OrphanedWorktrees int
        Cleaned           int
        Failed            int
        Errors            []string
}

// CleanupOperations provides business logic for cleanup operations
type CleanupOperations struct {
        stateManager *state.Manager
}

// NewCleanupOperations creates a new CleanupOperations instance
func NewCleanupOperations(sm *state.Manager) *CleanupOperations <span class="cov8" title="1">{
        return &amp;CleanupOperations{
                stateManager: sm,
        }
}</span>

// FindAndCleanupStaleResources finds and optionally cleans up stale CWT resources
func (c *CleanupOperations) FindAndCleanupStaleResources(dryRun bool) (*CleanupStats, error) <span class="cov8" title="1">{
        stats := &amp;CleanupStats{
                Errors: make([]string, 0),
        }

        // Find stale sessions
        staleSessions, err := c.stateManager.FindStaleSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find stale sessions: %w", err)
        }</span>
        <span class="cov8" title="1">stats.StaleSessions = len(staleSessions)

        // Clean up stale sessions
        for _, session := range staleSessions </span><span class="cov8" title="1">{
                if dryRun </span><span class="cov8" title="1">{
                        fmt.Printf("Would clean up stale session: %s (tmux: %s, worktree: %s)\n", 
                                session.Core.Name, session.Core.TmuxSession, session.Core.WorktreePath)
                        continue</span>
                }

                <span class="cov8" title="1">if err := c.stateManager.DeleteSession(session.Core.ID); err != nil </span><span class="cov0" title="0">{
                        stats.Failed++
                        errMsg := fmt.Sprintf("Failed to delete session %s: %v", session.Core.Name, err)
                        stats.Errors = append(stats.Errors, errMsg)
                }</span> else<span class="cov8" title="1"> {
                        stats.Cleaned++
                }</span>
        }

        // Find orphaned tmux sessions
        <span class="cov8" title="1">orphanedTmux, err := c.findOrphanedTmuxSessions()
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to find orphaned tmux sessions: %w", err)
        }</span>
        <span class="cov8" title="1">stats.OrphanedTmux = len(orphanedTmux)

        // Clean up orphaned tmux sessions
        for _, tmuxSession := range orphanedTmux </span><span class="cov8" title="1">{
                if dryRun </span><span class="cov8" title="1">{
                        fmt.Printf("Would kill orphaned tmux session: %s\n", tmuxSession)
                        continue</span>
                }

                <span class="cov8" title="1">if err := c.killTmuxSession(tmuxSession); err != nil </span><span class="cov0" title="0">{
                        stats.Failed++
                        errMsg := fmt.Sprintf("Failed to kill tmux session %s: %v", tmuxSession, err)
                        stats.Errors = append(stats.Errors, errMsg)
                }</span> else<span class="cov8" title="1"> {
                        stats.Cleaned++
                }</span>
        }

        // Find orphaned worktrees
        <span class="cov8" title="1">orphanedWorktrees, err := c.findOrphanedWorktrees()
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to find orphaned worktrees: %w", err)
        }</span>
        <span class="cov8" title="1">stats.OrphanedWorktrees = len(orphanedWorktrees)

        // Clean up orphaned worktrees
        for _, worktree := range orphanedWorktrees </span><span class="cov8" title="1">{
                if dryRun </span><span class="cov0" title="0">{
                        fmt.Printf("Would remove orphaned worktree: %s\n", worktree)
                        continue</span>
                }

                <span class="cov8" title="1">if err := c.removeWorktree(worktree); err != nil </span><span class="cov0" title="0">{
                        stats.Failed++
                        errMsg := fmt.Sprintf("Failed to remove worktree %s: %v", worktree, err)
                        stats.Errors = append(stats.Errors, errMsg)
                }</span> else<span class="cov8" title="1"> {
                        stats.Cleaned++
                }</span>
        }

        <span class="cov8" title="1">return stats, nil</span>
}

// findOrphanedTmuxSessions finds tmux sessions that start with "cwt-" but don't have corresponding CWT sessions
func (c *CleanupOperations) findOrphanedTmuxSessions() ([]string, error) <span class="cov8" title="1">{
        // Get all tmux sessions
        tmuxSessions, err := c.stateManager.GetTmuxChecker().ListSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tmux sessions: %w", err)
        }</span>

        // Get current CWT sessions
        <span class="cov8" title="1">sessions, err := c.stateManager.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current sessions: %w", err)
        }</span>

        // Create a map of active CWT tmux session names
        <span class="cov8" title="1">activeTmux := make(map[string]bool)
        for _, session := range sessions </span><span class="cov8" title="1">{
                activeTmux[session.Core.TmuxSession] = true
        }</span>

        // Find orphaned sessions
        <span class="cov8" title="1">var orphaned []string
        for _, tmuxSession := range tmuxSessions </span><span class="cov8" title="1">{
                if strings.HasPrefix(tmuxSession, "cwt-") &amp;&amp; !activeTmux[tmuxSession] </span><span class="cov8" title="1">{
                        orphaned = append(orphaned, tmuxSession)
                }</span>
        }

        <span class="cov8" title="1">return orphaned, nil</span>
}

// findOrphanedWorktrees finds git worktrees in .cwt/worktrees/ that don't have corresponding CWT sessions
func (c *CleanupOperations) findOrphanedWorktrees() ([]string, error) <span class="cov8" title="1">{
        worktreesDir := filepath.Join(c.stateManager.GetDataDir(), "worktrees")
        
        // Check if worktrees directory exists
        if _, err := os.Stat(worktreesDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, nil // No worktrees directory means no orphaned worktrees
        }</span>

        // Get all worktree directories
        <span class="cov8" title="1">entries, err := os.ReadDir(worktreesDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read worktrees directory: %w", err)
        }</span>

        // Get current CWT sessions
        <span class="cov8" title="1">sessions, err := c.stateManager.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current sessions: %w", err)
        }</span>

        // Create a map of active session names
        <span class="cov8" title="1">activeNames := make(map[string]bool)
        for _, session := range sessions </span><span class="cov8" title="1">{
                activeNames[session.Core.Name] = true
        }</span>

        // Find orphaned worktrees
        <span class="cov8" title="1">var orphaned []string
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() &amp;&amp; !activeNames[entry.Name()] </span><span class="cov8" title="1">{
                        orphaned = append(orphaned, entry.Name())
                }</span>
        }

        <span class="cov8" title="1">return orphaned, nil</span>
}

// killTmuxSession kills a tmux session
func (c *CleanupOperations) killTmuxSession(sessionName string) error <span class="cov8" title="1">{
        return c.stateManager.GetTmuxChecker().KillSession(sessionName)
}</span>

// removeWorktree removes a git worktree
func (c *CleanupOperations) removeWorktree(name string) error <span class="cov8" title="1">{
        worktreePath := filepath.Join(c.stateManager.GetDataDir(), "worktrees", name)
        
        // Use git worktree remove command
        cmd := exec.Command("git", "worktree", "remove", worktreePath)
        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                // If git worktree remove fails, try force removal
                cmd = exec.Command("git", "worktree", "remove", "--force", worktreePath)
                if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                        // If that also fails, remove the directory manually
                        return os.RemoveAll(worktreePath)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package operations

import (
        "fmt"
        "strings"
        "time"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// StatusFormat defines how to format session status information
type StatusFormat struct {
        // Add configuration options if needed in the future
}

// NewStatusFormat creates a new StatusFormat instance
func NewStatusFormat() *StatusFormat <span class="cov8" title="1">{
        return &amp;StatusFormat{}
}</span>

// FormatTmuxStatus formats the tmux status with appropriate emoji and color
func (f *StatusFormat) FormatTmuxStatus(isAlive bool) string <span class="cov8" title="1">{
        if isAlive </span><span class="cov8" title="1">{
                return "üü¢ alive"
        }</span>
        <span class="cov8" title="1">return "üî¥ dead"</span>
}

// FormatClaudeStatus formats the Claude status with appropriate emoji and details
func (f *StatusFormat) FormatClaudeStatus(claudeStatus types.ClaudeStatus) string <span class="cov8" title="1">{
        switch claudeStatus.State </span>{
        case types.ClaudeWorking:<span class="cov8" title="1">
                return "üîµ working"</span>
        case types.ClaudeWaiting:<span class="cov8" title="1">
                if claudeStatus.StatusMessage != "" </span><span class="cov8" title="1">{
                        return fmt.Sprintf("‚è∏Ô∏è %s", claudeStatus.StatusMessage)
                }</span>
                <span class="cov8" title="1">return "‚è∏Ô∏è waiting"</span>
        case types.ClaudeComplete:<span class="cov8" title="1">
                return "‚úÖ complete"</span>
        case types.ClaudeIdle:<span class="cov8" title="1">
                return "üü° idle"</span>
        case types.ClaudeUnknown:<span class="cov8" title="1">
                return "‚ùì unknown"</span>
        default:<span class="cov0" title="0">
                return "‚ùì unknown"</span>
        }
}

// FormatGitStatus formats the git status with file change information
func (f *StatusFormat) FormatGitStatus(gitStatus types.GitStatus) string <span class="cov8" title="1">{
        if !gitStatus.HasChanges </span><span class="cov8" title="1">{
                return "üü¢ clean"
        }</span>

        <span class="cov8" title="1">parts := []string{}
        
        if len(gitStatus.ModifiedFiles) &gt; 0 </span><span class="cov8" title="1">{
                if len(gitStatus.ModifiedFiles) == 1 </span><span class="cov8" title="1">{
                        parts = append(parts, "1 file")
                }</span> else<span class="cov8" title="1"> {
                        parts = append(parts, fmt.Sprintf("%d files", len(gitStatus.ModifiedFiles)))
                }</span>
        }
        
        <span class="cov8" title="1">if len(gitStatus.UntrackedFiles) &gt; 0 </span><span class="cov8" title="1">{
                if len(gitStatus.UntrackedFiles) == 1 </span><span class="cov8" title="1">{
                        parts = append(parts, "1 untracked")
                }</span> else<span class="cov8" title="1"> {
                        parts = append(parts, fmt.Sprintf("%d untracked", len(gitStatus.UntrackedFiles)))
                }</span>
        }

        <span class="cov8" title="1">if len(parts) == 0 </span><span class="cov8" title="1">{
                return "üü° changes"
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("üü° %s", strings.Join(parts, ", "))</span>
}

// FormatActivity formats the last activity time
func (f *StatusFormat) FormatActivity(lastActivity time.Time) string <span class="cov8" title="1">{
        if lastActivity.IsZero() </span><span class="cov8" title="1">{
                return "never"
        }</span>

        <span class="cov8" title="1">duration := time.Since(lastActivity)
        return f.FormatDuration(duration) + " ago"</span>
}

// FormatDuration formats a duration in a human-readable way
func (f *StatusFormat) FormatDuration(duration time.Duration) string <span class="cov8" title="1">{
        if duration &lt; time.Minute </span><span class="cov8" title="1">{
                return "just now"
        }</span> else<span class="cov8" title="1"> if duration &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(duration.Minutes())
                if minutes == 1 </span><span class="cov8" title="1">{
                        return "1 minute"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d minutes", minutes)</span>
        } else<span class="cov8" title="1"> if duration &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(duration.Hours())
                if hours == 1 </span><span class="cov8" title="1">{
                        return "1 hour"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d hours", hours)</span>
        } else<span class="cov8" title="1"> {
                days := int(duration.Hours() / 24)
                if days == 1 </span><span class="cov8" title="1">{
                        return "1 day"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d days", days)</span>
        }
}

// FormatSessionSummary creates a one-line summary of a session's status
func (f *StatusFormat) FormatSessionSummary(session types.Session) string <span class="cov8" title="1">{
        tmux := f.FormatTmuxStatus(session.IsAlive)
        claude := f.FormatClaudeStatus(session.ClaudeStatus)
        git := f.FormatGitStatus(session.GitStatus)
        activity := f.FormatActivity(session.LastActivity)

        return fmt.Sprintf("tmux: %s | claude: %s | git: %s | activity: %s", 
                tmux, claude, git, activity)
}</span>

// FormatSessionList formats a list of sessions for display
func (f *StatusFormat) FormatSessionList(sessions []types.Session, detailed bool) string <span class="cov8" title="1">{
        if len(sessions) == 0 </span><span class="cov8" title="1">{
                return "No sessions found."
        }</span>

        <span class="cov8" title="1">var result strings.Builder
        
        for i, session := range sessions </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteString("\n")
                }</span>
                
                <span class="cov8" title="1">result.WriteString(fmt.Sprintf("üìÇ %s", session.Core.Name))
                
                if detailed </span><span class="cov8" title="1">{
                        result.WriteString(fmt.Sprintf(" (%s)", session.Core.ID))
                        result.WriteString(fmt.Sprintf("\n   %s", f.FormatSessionSummary(session)))
                        result.WriteString(fmt.Sprintf("\n   üìÅ %s", session.Core.WorktreePath))
                }</span> else<span class="cov8" title="1"> {
                        result.WriteString(fmt.Sprintf(" - %s", f.FormatSessionSummary(session)))
                }</span>
        }
        
        <span class="cov8" title="1">return result.String()</span>
}</pre>
		
		<pre class="file" id="file22" style="display: none">package operations

import (
        "fmt"
        "os"
        "os/exec"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// SessionOperations provides business logic for session management
type SessionOperations struct {
        stateManager *state.Manager
}

// NewSessionOperations creates a new SessionOperations instance
func NewSessionOperations(sm *state.Manager) *SessionOperations <span class="cov8" title="1">{
        return &amp;SessionOperations{
                stateManager: sm,
        }
}</span>

// CreateSession creates a new session with the given name
func (s *SessionOperations) CreateSession(name string) error <span class="cov8" title="1">{
        return s.stateManager.CreateSession(name)
}</span>

// DeleteSession deletes the session with the given ID
func (s *SessionOperations) DeleteSession(sessionID string) error <span class="cov8" title="1">{
        return s.stateManager.DeleteSession(sessionID)
}</span>

// FindSessionByName finds a session by its name
// Returns the session and its ID, or an error if not found
func (s *SessionOperations) FindSessionByName(name string) (*types.Session, string, error) <span class="cov8" title="1">{
        sessions, err := s.stateManager.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov8" title="1">for _, session := range sessions </span><span class="cov8" title="1">{
                if session.Core.Name == name </span><span class="cov8" title="1">{
                        return &amp;session, session.Core.ID, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, "", fmt.Errorf("session '%s' not found", name)</span>
}

// FindSessionByID finds a session by its ID
func (s *SessionOperations) FindSessionByID(sessionID string) (*types.Session, error) <span class="cov8" title="1">{
        sessions, err := s.stateManager.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        <span class="cov8" title="1">for _, session := range sessions </span><span class="cov8" title="1">{
                if session.Core.ID == sessionID </span><span class="cov8" title="1">{
                        return &amp;session, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("session with ID '%s' not found", sessionID)</span>
}

// GetAllSessions returns all current sessions
func (s *SessionOperations) GetAllSessions() ([]types.Session, error) <span class="cov8" title="1">{
        return s.stateManager.DeriveFreshSessions()
}</span>

// RecreateDeadSession recreates a tmux session for a session that has died
// This handles Claude session resumption if a previous session exists
func (s *SessionOperations) RecreateDeadSession(session *types.Session) error <span class="cov8" title="1">{
        claudeExec := FindClaudeExecutable()
        if claudeExec == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("claude executable not found in PATH")
        }</span>

        <span class="cov8" title="1">command := claudeExec

        // Check if there's an existing Claude session to resume
        if existingSessionID, err := s.stateManager.GetClaudeChecker().FindSessionID(session.Core.WorktreePath); err == nil &amp;&amp; existingSessionID != "" </span><span class="cov8" title="1">{
                command = fmt.Sprintf("%s -r %s", claudeExec, existingSessionID)
        }</span>

        // Create the tmux session
        <span class="cov8" title="1">tmuxChecker := s.stateManager.GetTmuxChecker()
        return tmuxChecker.CreateSession(session.Core.TmuxSession, session.Core.WorktreePath, command)</span>
}

// FindClaudeExecutable searches for the Claude CLI executable in common locations
func FindClaudeExecutable() string <span class="cov8" title="1">{
        claudePaths := []string{
                "claude",
                os.ExpandEnv("$HOME/.claude/local/claude"),
                os.ExpandEnv("$HOME/.claude/local/node_modules/.bin/claude"),
                "/usr/local/bin/claude",
        }

        for _, path := range claudePaths </span><span class="cov8" title="1">{
                if _, err := exec.LookPath(path); err == nil </span><span class="cov8" title="1">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package state

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/jlaneve/cwt-cli/internal/clients/claude"
        "github.com/jlaneve/cwt-cli/internal/clients/git"
        "github.com/jlaneve/cwt-cli/internal/clients/tmux"
        "github.com/jlaneve/cwt-cli/internal/events"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// Config holds configuration for the StateManager
type Config struct {
        DataDir       string         // Directory for storing session data (e.g., ".cwt")
        TmuxChecker   tmux.Checker   // Injectable tmux operations
        ClaudeChecker claude.Checker // Injectable Claude operations
        GitChecker    git.Checker    // Injectable git operations
        BaseBranch    string         // Base branch for creating worktrees (default: "main")
}

// Manager handles all session state operations
type Manager struct {
        config   Config
        eventBus *events.Bus
        mu       sync.RWMutex
        dataFile string
}

// NewManager creates a new StateManager with the given configuration
func NewManager(config Config) *Manager <span class="cov8" title="1">{
        if config.DataDir == "" </span><span class="cov0" title="0">{
                config.DataDir = ".cwt"
        }</span>
        <span class="cov8" title="1">if config.BaseBranch == "" </span><span class="cov0" title="0">{
                config.BaseBranch = "main"
        }</span>

        // Use real checkers if not provided
        <span class="cov8" title="1">if config.TmuxChecker == nil </span><span class="cov0" title="0">{
                config.TmuxChecker = tmux.NewRealChecker()
        }</span>
        <span class="cov8" title="1">if config.GitChecker == nil </span><span class="cov0" title="0">{
                config.GitChecker = git.NewRealChecker(config.BaseBranch)
        }</span>
        <span class="cov8" title="1">if config.ClaudeChecker == nil </span><span class="cov0" title="0">{
                config.ClaudeChecker = claude.NewRealChecker(config.TmuxChecker)
        }</span>

        <span class="cov8" title="1">return &amp;Manager{
                config:   config,
                eventBus: events.NewBus(),
                dataFile: filepath.Join(config.DataDir, "sessions.json"),
        }</span>
}

// EventBus returns the event bus for subscribing to events
func (m *Manager) EventBus() &lt;-chan types.Event <span class="cov0" title="0">{
        return m.eventBus.Subscribe()
}</span>

// DeriveFreshSessions loads core sessions and derives complete state from external systems
func (m *Manager) DeriveFreshSessions() ([]types.Session, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        cores, err := m.loadCoreSessions()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to load core sessions: %w", err)
        }</span>

        <span class="cov8" title="1">sessions := make([]types.Session, len(cores))
        for i, core := range cores </span><span class="cov8" title="1">{
                sessions[i] = m.deriveSession(core)
        }</span>

        <span class="cov8" title="1">return sessions, nil</span>
}

// CreateSession creates a new session with all required resources
func (m *Manager) CreateSession(name string) error <span class="cov8" title="1">{
        // Validate session name
        if err := validateSessionName(name); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid session name: %w", err)
        }</span>

        // Emit immediate event for UI feedback
        <span class="cov8" title="1">m.eventBus.Publish(types.SessionCreationStarted{
                Name: name,
        })

        // Generate core session
        core := types.CoreSession{
                ID:           generateSessionID(),
                Name:         name,
                WorktreePath: filepath.Join(m.config.DataDir, "worktrees", name),
                TmuxSession:  fmt.Sprintf("cwt-%s", name),
                CreatedAt:    time.Now(),
        }

        // Check for duplicate session name
        if err := m.checkDuplicateName(name); err != nil </span><span class="cov0" title="0">{
                m.eventBus.Publish(types.SessionCreationFailed{
                        Name:  name,
                        Error: err.Error(),
                })
                return err
        }</span>

        // Create external resources with rollback on failure
        <span class="cov8" title="1">if err := m.createExternalResources(core); err != nil </span><span class="cov0" title="0">{
                m.eventBus.Publish(types.SessionCreationFailed{
                        Name:  name,
                        Error: err.Error(),
                })
                return err
        }</span>

        // Save to persistent storage
        <span class="cov8" title="1">if err := m.addCoreSession(core); err != nil </span><span class="cov0" title="0">{
                // Rollback external resources
                m.cleanupExternalResources(core)
                m.eventBus.Publish(types.SessionCreationFailed{
                        Name:  name,
                        Error: err.Error(),
                })
                return fmt.Errorf("failed to save session: %w", err)
        }</span>

        // Emit success event with derived session
        <span class="cov8" title="1">session := m.deriveSession(core)
        m.eventBus.Publish(types.SessionCreated{Session: session})

        return nil</span>
}

// DeleteSession removes a session and all its resources
func (m *Manager) DeleteSession(sessionID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        cores, err := m.loadCoreSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sessions: %w", err)
        }</span>

        // Find session to delete
        <span class="cov8" title="1">var sessionToDelete *types.CoreSession
        var newCores []types.CoreSession

        for _, core := range cores </span><span class="cov8" title="1">{
                if core.ID == sessionID </span><span class="cov8" title="1">{
                        sessionToDelete = &amp;core
                }</span> else<span class="cov0" title="0"> {
                        newCores = append(newCores, core)
                }</span>
        }

        <span class="cov8" title="1">if sessionToDelete == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("session with ID %s not found", sessionID)
                m.eventBus.Publish(types.SessionDeletionFailed{
                        SessionID: sessionID,
                        Error:     err.Error(),
                })
                return err
        }</span>

        // Clean up external resources
        <span class="cov8" title="1">m.cleanupExternalResources(*sessionToDelete)

        // Save updated session list
        if err := m.saveCoreSessions(newCores); err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("failed to save updated sessions: %w", err)
                m.eventBus.Publish(types.SessionDeletionFailed{
                        SessionID: sessionID,
                        Error:     err.Error(),
                })
                return err
        }</span>

        // Emit success event
        <span class="cov8" title="1">m.eventBus.Publish(types.SessionDeleted{SessionID: sessionID})

        return nil</span>
}

// FindStaleSessions returns sessions that have dead tmux sessions
func (m *Manager) FindStaleSessions() ([]types.Session, error) <span class="cov8" title="1">{
        sessions, err := m.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stale []types.Session
        for _, session := range sessions </span><span class="cov8" title="1">{
                if !session.IsAlive </span><span class="cov8" title="1">{
                        stale = append(stale, session)
                }</span>
        }

        <span class="cov8" title="1">return stale, nil</span>
}

// Private methods

func (m *Manager) deriveSession(core types.CoreSession) types.Session <span class="cov8" title="1">{
        session := types.Session{
                Core:      core,
                IsAlive:   m.config.TmuxChecker.IsSessionAlive(core.TmuxSession),
                GitStatus: m.config.GitChecker.GetStatus(core.WorktreePath),
        }

        // Load Claude status from session state file (preferred) or fallback to checker
        if sessionState, err := types.LoadSessionState(m.config.DataDir, core.ID); err == nil &amp;&amp; sessionState != nil </span><span class="cov0" title="0">{
                session.ClaudeStatus = types.GetClaudeStatusFromState(sessionState)
        }</span> else<span class="cov8" title="1"> {
                // Fallback to old JSONL scanning if no session state
                session.ClaudeStatus = m.config.ClaudeChecker.GetStatus(core.WorktreePath)
        }</span>

        // Calculate last activity from available timestamps
        <span class="cov8" title="1">session.LastActivity = m.calculateLastActivity(session)

        return session</span>
}

func (m *Manager) calculateLastActivity(session types.Session) time.Time <span class="cov8" title="1">{
        lastActivity := session.Core.CreatedAt

        // Consider Claude activity
        if !session.ClaudeStatus.LastMessage.IsZero() &amp;&amp; session.ClaudeStatus.LastMessage.After(lastActivity) </span><span class="cov0" title="0">{
                lastActivity = session.ClaudeStatus.LastMessage
        }</span>

        // Consider git activity (would need file stat times, simplified for now)
        // In a full implementation, you'd check git log timestamps

        <span class="cov8" title="1">return lastActivity</span>
}

func (m *Manager) loadCoreSessions() ([]types.CoreSession, error) <span class="cov8" title="1">{
        if _, err := os.Stat(m.dataFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []types.CoreSession{}, nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(m.dataFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read sessions file: %w", err)
        }</span>

        <span class="cov8" title="1">var sessionData types.SessionData
        if err := json.Unmarshal(data, &amp;sessionData); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sessions file corrupted: %w", err)
        }</span>

        <span class="cov8" title="1">return sessionData.Sessions, nil</span>
}

func (m *Manager) saveCoreSessions(sessions []types.CoreSession) error <span class="cov8" title="1">{
        // Ensure data directory exists
        if err := os.MkdirAll(m.config.DataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create data directory: %w", err)
        }</span>

        <span class="cov8" title="1">sessionData := types.SessionData{Sessions: sessions}
        data, err := json.MarshalIndent(sessionData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sessions: %w", err)
        }</span>

        // Atomic write using temporary file
        <span class="cov8" title="1">tempFile := m.dataFile + ".tmp"
        if err := os.WriteFile(tempFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temp file: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.Rename(tempFile, m.dataFile); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempFile) // Cleanup temp file
                return fmt.Errorf("failed to rename temp file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *Manager) addCoreSession(core types.CoreSession) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        sessions, err := m.loadCoreSessions()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sessions = append(sessions, core)
        return m.saveCoreSessions(sessions)</span>
}

func (m *Manager) checkDuplicateName(name string) error <span class="cov8" title="1">{
        sessions, err := m.loadCoreSessions()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, session := range sessions </span><span class="cov8" title="1">{
                if session.Name == name </span><span class="cov0" title="0">{
                        return fmt.Errorf("session with name '%s' already exists", name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *Manager) createExternalResources(core types.CoreSession) error <span class="cov8" title="1">{
        // Validate git repository first
        if err := m.config.GitChecker.IsValidRepository(""); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git repository validation failed: %w", err)
        }</span>

        // Create git worktree
        <span class="cov8" title="1">if err := m.config.GitChecker.CreateWorktree(core.Name, core.WorktreePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create git worktree: %w", err)
        }</span>

        // Create Claude settings with hooks in the worktree
        <span class="cov8" title="1">if err := m.createClaudeSettings(core.WorktreePath, core.ID); err != nil </span><span class="cov0" title="0">{
                // Rollback git worktree
                m.config.GitChecker.RemoveWorktree(core.WorktreePath)
                return fmt.Errorf("failed to create Claude settings: %w", err)
        }</span>

        // Create tmux session
        // Check if claude is available, otherwise create session without it
        <span class="cov8" title="1">var command string
        if claudeExec := m.findClaudeExecutable(); claudeExec != "" </span><span class="cov8" title="1">{
                command = claudeExec
        }</span>

        <span class="cov8" title="1">err := m.config.TmuxChecker.CreateSession(core.TmuxSession, core.WorktreePath, command)
        if err != nil </span><span class="cov0" title="0">{
                // Rollback git worktree
                m.config.GitChecker.RemoveWorktree(core.WorktreePath)
                return fmt.Errorf("failed to create tmux session: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *Manager) cleanupExternalResources(core types.CoreSession) <span class="cov8" title="1">{
        // Kill tmux session (ignore errors)
        m.config.TmuxChecker.KillSession(core.TmuxSession)

        // Remove git worktree (ignore errors)
        m.config.GitChecker.RemoveWorktree(core.WorktreePath)

        // Remove session state file (ignore errors)
        types.RemoveSessionState(m.config.DataDir, core.ID)
}</span>

func generateSessionID() string <span class="cov8" title="1">{
        return fmt.Sprintf("session-%d", time.Now().UnixNano())
}</span>

// createClaudeSettings creates a settings.json file in the worktree with CWT hooks configured
func (m *Manager) createClaudeSettings(worktreePath, sessionID string) error <span class="cov8" title="1">{
        claudeDir := filepath.Join(worktreePath, ".claude")
        settingsPath := filepath.Join(claudeDir, "settings.json")

        // Ensure .claude directory exists
        if err := os.MkdirAll(claudeDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .claude directory: %w", err)
        }</span>

        // Get the current cwt executable path
        <span class="cov8" title="1">cwtPath := m.getCwtExecutablePath()

        settings := map[string]interface{}{
                "hooks": map[string]interface{}{
                        "Notification": []map[string]interface{}{
                                {
                                        "matcher": "",
                                        "hooks": []map[string]interface{}{
                                                {
                                                        "type":    "command",
                                                        "command": fmt.Sprintf("%s __hook %s notification", cwtPath, sessionID),
                                                },
                                        },
                                },
                        },
                        "Stop": []map[string]interface{}{
                                {
                                        "matcher": "",
                                        "hooks": []map[string]interface{}{
                                                {
                                                        "type":    "command",
                                                        "command": fmt.Sprintf("%s __hook %s stop", cwtPath, sessionID),
                                                },
                                        },
                                },
                        },
                        "PreToolUse": []map[string]interface{}{
                                {
                                        "matcher": "",
                                        "hooks": []map[string]interface{}{
                                                {
                                                        "type":    "command",
                                                        "command": fmt.Sprintf("%s __hook %s pre_tool_use", cwtPath, sessionID),
                                                },
                                        },
                                },
                        },
                        "PostToolUse": []map[string]interface{}{
                                {
                                        "matcher": "",
                                        "hooks": []map[string]interface{}{
                                                {
                                                        "type":    "command",
                                                        "command": fmt.Sprintf("%s __hook %s post_tool_use", cwtPath, sessionID),
                                                },
                                        },
                                },
                        },
                        "SubagentStop": []map[string]interface{}{
                                {
                                        "matcher": "",
                                        "hooks": []map[string]interface{}{
                                                {
                                                        "type":    "command",
                                                        "command": fmt.Sprintf("%s __hook %s subagent_stop", cwtPath, sessionID),
                                                },
                                        },
                                },
                        },
                        "PreCompact": []map[string]interface{}{
                                {
                                        "matcher": "",
                                        "hooks": []map[string]interface{}{
                                                {
                                                        "type":    "command",
                                                        "command": fmt.Sprintf("%s __hook %s pre_compact", cwtPath, sessionID),
                                                },
                                        },
                                },
                        },
                },
        }

        data, err := json.MarshalIndent(settings, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal Claude settings: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(settingsPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write Claude settings file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getCwtExecutablePath determines the best path to use for cwt executable
func (m *Manager) getCwtExecutablePath() string <span class="cov8" title="1">{
        // First, try to find cwt in PATH (most reliable for installed binaries)
        if path, err := exec.LookPath("cwt"); err == nil </span><span class="cov0" title="0">{
                return path
        }</span>

        // Check if we're running from go run (has temp executable path)
        <span class="cov8" title="1">if execPath, err := os.Executable(); err == nil </span><span class="cov8" title="1">{
                // If it's a temp path from go run, use absolute path to "go run cmd/cwt/main.go"
                if strings.Contains(execPath, "go-build") || strings.Contains(execPath, "/tmp/") </span><span class="cov8" title="1">{
                        // Get current working directory to build absolute path
                        if wd, err := os.Getwd(); err == nil </span><span class="cov8" title="1">{
                                // Check if we're in the cwt project directory
                                mainGoPath := filepath.Join(wd, "cmd/cwt/main.go")
                                if _, err := os.Stat(mainGoPath); err == nil </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("cd %s &amp;&amp; go run cmd/cwt/main.go", wd)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // It's a real executable path
                        return execPath
                }</span>
        }

        // Final fallback to "cwt" in PATH
        <span class="cov8" title="1">return "cwt"</span>
}

// findClaudeExecutable searches for claude in common installation paths
func (m *Manager) findClaudeExecutable() string <span class="cov8" title="1">{
        // Check common installation paths
        claudePaths := []string{
                "claude",
                os.ExpandEnv("$HOME/.claude/local/claude"),
                os.ExpandEnv("$HOME/.claude/local/node_modules/.bin/claude"),
                "/usr/local/bin/claude",
        }

        for _, path := range claudePaths </span><span class="cov8" title="1">{
                cmd := exec.Command(path, "--version")
                if err := cmd.Run(); err == nil </span><span class="cov8" title="1">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// GetDataDir returns the data directory path
func (m *Manager) GetDataDir() string <span class="cov0" title="0">{
        return m.config.DataDir
}</span>

// GetTmuxChecker returns the tmux checker for direct access
func (m *Manager) GetTmuxChecker() tmux.Checker <span class="cov0" title="0">{
        return m.config.TmuxChecker
}</span>

// GetClaudeChecker returns the claude checker for direct access
func (m *Manager) GetClaudeChecker() claude.Checker <span class="cov0" title="0">{
        return m.config.ClaudeChecker
}</span>

// Close cleans up the manager resources
func (m *Manager) Close() <span class="cov0" title="0">{
        m.eventBus.Close()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package state

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "unicode"
)

// validateSessionName validates a session name according to git branch naming rules
// Based on the validation logic from archive/internal/cli/new.go
func validateSessionName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("session name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 50 </span><span class="cov8" title="1">{
                return fmt.Errorf("session name too long (max 50 characters)")
        }</span>

        // Check for invalid characters
        <span class="cov8" title="1">invalidChars := []string{" ", "~", "^", ":", "?", "*", "[", "\\", "..", "@{"}
        for _, char := range invalidChars </span><span class="cov8" title="1">{
                if strings.Contains(name, char) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid characters in session name: '%s' not allowed", char)
                }</span>
        }

        // Cannot start or end with certain characters
        <span class="cov8" title="1">invalidStartEnd := []string{"-", "/", "."}
        for _, char := range invalidStartEnd </span><span class="cov8" title="1">{
                if strings.HasPrefix(name, char) || strings.HasSuffix(name, char) </span><span class="cov8" title="1">{
                        return fmt.Errorf("session name cannot start or end with '%s'", char)
                }</span>
        }

        // Cannot be just numbers
        <span class="cov8" title="1">if isNumericOnly(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("session name cannot be just numbers")
        }</span>

        // Check for reserved names
        <span class="cov8" title="1">reservedNames := []string{"main", "master", "HEAD", "refs"}
        for _, reserved := range reservedNames </span><span class="cov8" title="1">{
                if strings.EqualFold(name, reserved) </span><span class="cov8" title="1">{
                        return fmt.Errorf("'%s' is a reserved name and cannot be used", name)
                }</span>
        }

        // Additional git ref name validation
        <span class="cov8" title="1">if !isValidGitRefName(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("session name must be a valid git branch name")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isNumericOnly(s string) bool <span class="cov8" title="1">{
        _, err := strconv.Atoi(s)
        return err == nil
}</span>

func isValidGitRefName(name string) bool <span class="cov8" title="1">{
        // Git ref name rules (simplified):
        // - ASCII control characters (&lt; 32 or 127) are not allowed
        // - Space, ~, ^, :, ?, *, [, \ are not allowed (already checked above)
        // - Cannot be empty or start with /
        // - Cannot end with .lock
        // - Cannot contain .. or @{
        // - Cannot start or end with /
        // - No zero-width or format characters

        if strings.HasSuffix(name, ".lock") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for ASCII control characters and problematic Unicode characters
        <span class="cov8" title="1">for _, r := range name </span><span class="cov8" title="1">{
                if r &lt; 32 || r == 127 </span><span class="cov8" title="1">{
                        return false
                }</span>
                // Only reject zero-width and format characters that cause issues
                // Cf = Format characters (includes zero-width space, etc.)
                <span class="cov8" title="1">if unicode.In(r, unicode.Cf) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Must contain at least one valid character that's not a special character
        <span class="cov8" title="1">validCharRegex := regexp.MustCompile(`[a-zA-Z0-9_-]`)
        if !validCharRegex.MatchString(name) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package tui

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/fsnotify/fsnotify"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// startEventChannelListener creates a command that listens for file events
func (m Model) startEventChannelListener() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // This will block until an event is received
                return &lt;-m.eventChan
        }</span>
}

// File watching setup
func (m Model) setupFileWatching() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                watcher, err := fsnotify.NewWatcher()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to create file watcher: %w", err)}
                }</span>

                // Watch session state directory for hook events
                <span class="cov0" title="0">sessionStateDir := filepath.Join(m.stateManager.GetDataDir(), "session-state")
                if err := os.MkdirAll(sessionStateDir, 0755); err == nil </span><span class="cov0" title="0">{
                        if err := watcher.Add(sessionStateDir); err != nil </span><span class="cov0" title="0">{
                                return errorMsg{err: fmt.Errorf("failed to watch session state directory: %w", err)}
                        }</span>
                        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("Watching session state directory: %s", sessionStateDir)
                        }</span>
                }

                // Watch sessions.json for session CRUD
                <span class="cov0" title="0">sessionsFile := filepath.Join(m.stateManager.GetDataDir(), "sessions.json")
                if _, err := os.Stat(sessionsFile); err == nil </span><span class="cov0" title="0">{
                        if err := watcher.Add(sessionsFile); err != nil </span><span class="cov0" title="0">{
                                return errorMsg{err: fmt.Errorf("failed to watch sessions file: %w", err)}
                        }</span>
                        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("Watching sessions file: %s", sessionsFile)
                        }</span>
                }

                // Watch git index files for each session
                <span class="cov0" title="0">for _, session := range m.sessions </span><span class="cov0" title="0">{
                        m.addSessionWatches(watcher, session)
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                gitIndexPath := filepath.Join(session.Core.WorktreePath, ".git", "index")
                                debugLogger.Printf("Watching git index for session %s: %s", session.Core.Name, gitIndexPath)
                        }</span>
                }

                // Store the eventChan in the watcher context
                <span class="cov0" title="0">eventChan := m.eventChan

                // Start listening for file events
                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                return
                                        }</span>

                                        // Debug logging for file events
                                        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                                                debugLogger.Printf("File event: %s %s", event.Op, event.Name)
                                        }</span>

                                        // Determine event type based on file path and send appropriate message
                                        <span class="cov0" title="0">if filepath.Base(filepath.Dir(event.Name)) == "session-state" </span><span class="cov0" title="0">{
                                                // Session state change (hook event)
                                                go func() </span><span class="cov0" title="0">{
                                                        time.Sleep(100 * time.Millisecond) // Debounce
                                                        if debugLogger != nil </span><span class="cov0" title="0">{
                                                                debugLogger.Printf("Sending sessionStateChangedMsg for: %s", event.Name)
                                                        }</span>
                                                        <span class="cov0" title="0">select </span>{
                                                        case eventChan &lt;- sessionStateChangedMsg{}:<span class="cov0" title="0"></span>
                                                        default:<span class="cov0" title="0"> // Channel full, skip this event
                                                                if debugLogger != nil </span><span class="cov0" title="0">{
                                                                        debugLogger.Printf("Event channel full, skipping sessionStateChangedMsg")
                                                                }</span>
                                                        }
                                                }()
                                        } else<span class="cov0" title="0"> if filepath.Base(event.Name) == "sessions.json" </span><span class="cov0" title="0">{
                                                // Session list change
                                                go func() </span><span class="cov0" title="0">{
                                                        time.Sleep(100 * time.Millisecond) // Debounce
                                                        if debugLogger != nil </span><span class="cov0" title="0">{
                                                                debugLogger.Printf("Sending sessionListChangedMsg for: %s", event.Name)
                                                        }</span>
                                                        <span class="cov0" title="0">select </span>{
                                                        case eventChan &lt;- sessionListChangedMsg{}:<span class="cov0" title="0"></span>
                                                        default:<span class="cov0" title="0"> // Channel full, skip this event
                                                                if debugLogger != nil </span><span class="cov0" title="0">{
                                                                        debugLogger.Printf("Event channel full, skipping sessionListChangedMsg")
                                                                }</span>
                                                        }
                                                }()
                                        } else<span class="cov0" title="0"> if filepath.Base(event.Name) == "index" </span><span class="cov0" title="0">{
                                                // Git index change
                                                sessionID := m.getSessionIDFromPath(event.Name)
                                                if sessionID != "" </span><span class="cov0" title="0">{
                                                        go func(sID string) </span><span class="cov0" title="0">{
                                                                time.Sleep(100 * time.Millisecond) // Debounce
                                                                if debugLogger != nil </span><span class="cov0" title="0">{
                                                                        debugLogger.Printf("Sending gitIndexChangedMsg for session: %s", sID)
                                                                }</span>
                                                                <span class="cov0" title="0">select </span>{
                                                                case eventChan &lt;- gitIndexChangedMsg{sessionID: sID}:<span class="cov0" title="0"></span>
                                                                default:<span class="cov0" title="0"> // Channel full, skip this event
                                                                        if debugLogger != nil </span><span class="cov0" title="0">{
                                                                                debugLogger.Printf("Event channel full, skipping gitIndexChangedMsg")
                                                                        }</span>
                                                                }
                                                        }(sessionID)
                                                }
                                        }

                                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        // Send error message to TUI
                                        <span class="cov0" title="0">select </span>{
                                        case eventChan &lt;- errorMsg{err: fmt.Errorf("file watcher error: %w", err)}:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span> // Channel full, skip this event
                                        }
                                }
                        }
                }()

                // Return the watcher setup message so the model can store it
                <span class="cov0" title="0">return fileWatcherSetupMsg{watcher: watcher}</span>
        }
}

// Helper to add git index watching for a session
func (m Model) addSessionWatches(watcher *fsnotify.Watcher, session types.Session) <span class="cov0" title="0">{
        gitIndexPath := filepath.Join(session.Core.WorktreePath, ".git", "index")
        if _, err := os.Stat(gitIndexPath); err == nil </span><span class="cov0" title="0">{
                watcher.Add(gitIndexPath)
        }</span>
}

// addNewSessionWatches adds file watches for a newly created session
func (m Model) addNewSessionWatches(session types.Session) <span class="cov0" title="0">{
        if m.fileWatcher != nil </span><span class="cov0" title="0">{
                m.addSessionWatches(m.fileWatcher, session)
        }</span>
}

// Helper to extract session ID from git index path
func (m Model) getSessionIDFromPath(path string) string <span class="cov0" title="0">{
        // Extract session ID from path like .cwt/worktrees/session-name/.git/index
        // This is a simplified version - in practice, we'd need to map paths to session IDs
        for _, session := range m.sessions </span><span class="cov0" title="0">{
                if filepath.Dir(path) == filepath.Join(session.Core.WorktreePath, ".git") </span><span class="cov0" title="0">{
                        return session.Core.ID
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Polling commands
func (m Model) startGitPolling() tea.Cmd <span class="cov0" title="0">{
        return tea.Every(10*time.Second, func(time.Time) tea.Msg </span><span class="cov0" title="0">{
                return gitStatusRefreshMsg{}
        }</span>)
}

func (m Model) startTmuxPolling() tea.Cmd <span class="cov0" title="0">{
        return tea.Every(30*time.Second, func(time.Time) tea.Msg </span><span class="cov0" title="0">{
                return tmuxStatusRefreshMsg{}
        }</span>)
}

// Session management commands
func (m Model) refreshSessions() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                sessions, err := m.stateManager.DeriveFreshSessions()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to refresh sessions: %w", err)}
                }</span>
                <span class="cov0" title="0">return refreshCompleteMsg{sessions: sessions}</span>
        }
}

func (m Model) refreshSessionGitStatus(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Refresh just git status for specific session
                // For now, refresh all sessions (optimize later)
                sessions, err := m.stateManager.DeriveFreshSessions()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to refresh git status: %w", err)}
                }</span>
                <span class="cov0" title="0">return refreshCompleteMsg{sessions: sessions}</span>
        }
}

func (m Model) refreshAllGitStatus() tea.Cmd <span class="cov0" title="0">{
        return m.refreshSessions() // For now, just refresh everything
}</span>

func (m Model) refreshTmuxStatus() tea.Cmd <span class="cov0" title="0">{
        return m.refreshSessions() // For now, just refresh everything
}</span>

// User action commands
func (m Model) handleAttach(sessionID string) tea.Cmd <span class="cov0" title="0">{
        // Get access to the logger from model.go
        return func() tea.Msg </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("handleAttach: Called with sessionID: %s", sessionID)
                }</span>

                <span class="cov0" title="0">session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("handleAttach: Session not found for ID: %s", sessionID)
                        }</span>
                        <span class="cov0" title="0">return errorMsg{err: fmt.Errorf("session not found")}</span>
                }

                <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("handleAttach: Found session: %s, IsAlive: %v", session.Core.Name, session.IsAlive)
                }</span>

                <span class="cov0" title="0">if !session.IsAlive </span><span class="cov0" title="0">{
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("handleAttach: Session %s is dead, showing confirmation dialog", session.Core.Name)
                        }</span>
                        // Return a command to show confirmation dialog
                        <span class="cov0" title="0">return showConfirmDialogMsg{
                                message: fmt.Sprintf("Session '%s' tmux is not running. Recreate it?", session.Core.Name),
                                onYes: func() tea.Cmd </span><span class="cov0" title="0">{
                                        return m.recreateAndAttach(sessionID)
                                }</span>,
                                onNo: func() tea.Cmd <span class="cov0" title="0">{
                                        return nil
                                }</span>,
                        }
                }

                <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("handleAttach: Session %s is alive, proceeding to attach", session.Core.Name)
                }</span>
                // Attach to alive session
                <span class="cov0" title="0">return m.attachToSession(sessionID)</span>
        }
}

func (m Model) recreateAndAttach(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session not found")}
                }</span>

                // Recreate the tmux session directly (worktree already exists)
                // Find claude executable
                <span class="cov0" title="0">claudeExec := m.findClaudeExecutable()
                var command string
                if claudeExec != "" </span><span class="cov0" title="0">{
                        // Check if there's an existing Claude session to resume for this worktree
                        if existingSessionID, err := m.stateManager.GetClaudeChecker().FindSessionID(session.Core.WorktreePath); err == nil &amp;&amp; existingSessionID != "" </span><span class="cov0" title="0">{
                                command = fmt.Sprintf("%s -r %s", claudeExec, existingSessionID)
                                if debugLogger != nil </span><span class="cov0" title="0">{
                                        debugLogger.Printf("Resuming Claude session %s for worktree %s", existingSessionID, session.Core.WorktreePath)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                command = claudeExec
                                if debugLogger != nil </span><span class="cov0" title="0">{
                                        debugLogger.Printf("Starting new Claude session for worktree %s", session.Core.WorktreePath)
                                }</span>
                        }
                }

                // Create new tmux session
                <span class="cov0" title="0">if err := m.stateManager.GetTmuxChecker().CreateSession(
                        session.Core.TmuxSession,
                        session.Core.WorktreePath,
                        command,
                ); err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to recreate tmux session: %w", err)}
                }</span>

                // Now request attachment
                <span class="cov0" title="0">return attachRequestMsg{sessionName: session.Core.TmuxSession}</span>
        }
}

func (m Model) attachToSession(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("attachToSession: Called with sessionID: %s", sessionID)
                }</span>

                <span class="cov0" title="0">session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("attachToSession: Session not found for ID: %s", sessionID)
                        }</span>
                        <span class="cov0" title="0">return errorMsg{err: fmt.Errorf("session not found")}</span>
                }

                <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("attachToSession: Returning attachRequestMsg for tmux session: %s", session.Core.TmuxSession)
                }</span>

                // Return a special message that tells the TUI to exit and attach
                <span class="cov0" title="0">return attachRequestMsg{sessionName: session.Core.TmuxSession}</span>
        }
}

// startSessionCreation is no longer needed - replaced with overlay dialog

func (m Model) confirmDelete(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session not found")}
                }</span>

                <span class="cov0" title="0">return showConfirmDialogMsg{
                        message: fmt.Sprintf("Delete session '%s' and all its resources?", session.Core.Name),
                        onYes: func() tea.Cmd </span><span class="cov0" title="0">{
                                return m.deleteSession(sessionID)
                        }</span>,
                        onNo: func() tea.Cmd <span class="cov0" title="0">{
                                return nil
                        }</span>,
                }
        }
}

func (m Model) deleteSession(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if err := m.stateManager.DeleteSession(sessionID); err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to delete session: %w", err)}
                }</span>

                // Refresh session list after deletion
                <span class="cov0" title="0">sessions, err := m.stateManager.DeriveFreshSessions()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to refresh after deletion: %w", err)}
                }</span>

                <span class="cov0" title="0">return refreshCompleteMsg{sessions: sessions}</span>
        }
}

func (m Model) runCleanup() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Find and clean up stale sessions
                staleSessions, err := m.stateManager.FindStaleSessions()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to find stale sessions: %w", err)}
                }</span>

                <span class="cov0" title="0">if len(staleSessions) == 0 </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("no orphaned sessions found")}
                }</span>

                // Clean up each stale session
                <span class="cov0" title="0">for _, session := range staleSessions </span><span class="cov0" title="0">{
                        if err := m.stateManager.DeleteSession(session.Core.ID); err != nil </span><span class="cov0" title="0">{
                                return errorMsg{err: fmt.Errorf("failed to cleanup session %s: %w", session.Core.Name, err)}
                        }</span>
                }

                // Refresh session list after cleanup
                <span class="cov0" title="0">sessions, err := m.stateManager.DeriveFreshSessions()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("failed to refresh after cleanup: %w", err)}
                }</span>

                <span class="cov0" title="0">return refreshCompleteMsg{sessions: sessions}</span>
        }
}

// findClaudeExecutable searches for claude in common installation paths
func (m Model) findClaudeExecutable() string <span class="cov0" title="0">{
        // Check common installation paths
        claudePaths := []string{
                "claude",
                os.ExpandEnv("$HOME/.claude/local/claude"),
                os.ExpandEnv("$HOME/.claude/local/node_modules/.bin/claude"),
                "/usr/local/bin/claude",
        }

        for _, path := range claudePaths </span><span class="cov0" title="0">{
                cmd := exec.Command(path, "--version")
                if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package tui

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/fsnotify/fsnotify"

        "github.com/jlaneve/cwt-cli/internal/state"
        "github.com/jlaneve/cwt-cli/internal/types"
)

// Global logger for debugging
var debugLogger *log.Logger

func init() <span class="cov8" title="1">{
        // Create debug log file
        logFile, err := os.OpenFile("cwt-tui-debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err == nil </span><span class="cov8" title="1">{
                debugLogger = log.New(logFile, "[TUI-DEBUG] ", log.LstdFlags|log.Lshortfile)
                debugLogger.Println("=== TUI Debug Session Started ===")
        }</span>
}

// Model represents the main TUI state
type Model struct {
        stateManager     *state.Manager
        sessions         []types.Session
        fileWatcher      *fsnotify.Watcher
        showHelp         bool
        confirmDialog    *ConfirmDialog
        newSessionDialog *NewSessionDialog
        lastError        string
        successMessage   string // For success toast notifications
        ready            bool
        attachOnExit     string // Session name to attach to when exiting TUI

        // Terminal dimensions
        width  int
        height int

        // Split-pane state
        selectedIndex int // Which session is selected in the left panel

        // Session creation tracking
        creatingSessions map[string]bool // Track sessions being created

        // Event channel for file watching
        eventChan chan tea.Msg
}

// ConfirmDialog represents a yes/no confirmation dialog
type ConfirmDialog struct {
        Message string
        OnYes   func() tea.Cmd
        OnNo    func() tea.Cmd
}

// NewSessionDialog represents a new session creation dialog
type NewSessionDialog struct {
        NameInput string
        Error     string
}

// Event messages for BubbleTea
type (
        // Immediate events (fsnotify)
        sessionStateChangedMsg struct{}
        sessionListChangedMsg  struct{}
        gitIndexChangedMsg     struct{ sessionID string }

        // Polling events
        gitStatusRefreshMsg  struct{}
        tmuxStatusRefreshMsg struct{}

        // User actions
        attachMsg        struct{ sessionID string }
        deleteMsg        struct{ sessionID string }
        createSessionMsg struct{ name string }

        // Internal events
        refreshCompleteMsg struct{ sessions []types.Session }
        errorMsg           struct{ err error }
        confirmYesMsg      struct{}
        confirmNoMsg       struct{}

        // Session creation status
        sessionCreatingMsg       struct{ name string }
        sessionCreatedMsg        struct{ name string }
        sessionCreationFailedMsg struct {
                name string
                err  error
        }

        // Toast messages
        clearSuccessMsg struct{}

        // Dialog events
        showConfirmDialogMsg struct {
                message string
                onYes   func() tea.Cmd
                onNo    func() tea.Cmd
        }

        // New session dialog events
        showNewSessionDialogMsg   struct{}
        newSessionDialogInputMsg  struct{ input string }
        newSessionDialogSubmitMsg struct{}
        newSessionDialogCancelMsg struct{}

        // Clear error message after delay
        clearErrorMsg struct{}

        // Attach request (exits TUI and attaches)
        attachRequestMsg struct{ sessionName string }

        // File watcher setup
        fileWatcherSetupMsg struct{ watcher *fsnotify.Watcher }
)

// NewModel creates a new TUI model
func NewModel(stateManager *state.Manager) (*Model, error) <span class="cov0" title="0">{
        if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Println("NewModel: Starting TUI model creation")
        }</span>

        // Load initial sessions
        <span class="cov0" title="0">sessions, err := stateManager.DeriveFreshSessions()
        if err != nil </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("NewModel: Failed to load sessions: %v", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load initial sessions: %w", err)</span>
        }

        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("NewModel: Loaded %d sessions", len(sessions))
                for i, s := range sessions </span><span class="cov0" title="0">{
                        debugLogger.Printf("NewModel: Session %d: ID=%s, Name=%s, IsAlive=%v", i, s.Core.ID, s.Core.Name, s.IsAlive)
                }</span>
        }

        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("NewModel: No table needed for split-pane layout")
        }</span>

        <span class="cov0" title="0">return &amp;Model{
                stateManager:     stateManager,
                sessions:         sessions,
                ready:            false,
                creatingSessions: make(map[string]bool),
                eventChan:        make(chan tea.Msg, 100), // Buffered channel for file events
        }, nil</span>
}

// Init initializes the TUI model with necessary setup
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                m.setupFileWatching(),
                m.startEventChannelListener(),
                m.startGitPolling(),
                m.startTmuxPolling(),
                func() tea.Msg </span><span class="cov0" title="0">{ return refreshCompleteMsg{sessions: m.sessions} }</span>,
        )
}

// Update handles all TUI events and state changes
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                return m.handleKeyPress(msg)</span>

        case refreshCompleteMsg:<span class="cov0" title="0">
                // Store old sessions to detect new ones
                oldSessionIDs := make(map[string]bool)
                for _, session := range m.sessions </span><span class="cov0" title="0">{
                        oldSessionIDs[session.Core.ID] = true
                }</span>

                // Update sessions
                <span class="cov0" title="0">m.sessions = msg.sessions

                // Ensure selectedIndex is within bounds
                totalItems := len(m.sessions) + len(m.creatingSessions)
                if m.selectedIndex &gt;= totalItems </span><span class="cov0" title="0">{
                        m.selectedIndex = totalItems - 1
                }</span>
                <span class="cov0" title="0">if m.selectedIndex &lt; 0 </span><span class="cov0" title="0">{
                        m.selectedIndex = 0
                }</span>

                <span class="cov0" title="0">m.ready = true

                // Add watches for any new sessions
                if m.fileWatcher != nil </span><span class="cov0" title="0">{
                        for _, session := range m.sessions </span><span class="cov0" title="0">{
                                if !oldSessionIDs[session.Core.ID] </span><span class="cov0" title="0">{
                                        // This is a new session, add watches
                                        m.addNewSessionWatches(session)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return m, nil</span>

        case sessionStateChangedMsg:<span class="cov0" title="0">
                // High priority: Claude state changes (hook events)
                return m, tea.Batch(
                        m.refreshSessions(),
                        m.startEventChannelListener(), // Restart listener
                )</span>

        case sessionListChangedMsg:<span class="cov0" title="0">
                // High priority: Session CRUD operations
                return m, tea.Batch(
                        m.refreshSessions(),
                        m.startEventChannelListener(), // Restart listener
                )</span>

        case gitIndexChangedMsg:<span class="cov0" title="0">
                // Medium priority: Git staging operations
                return m, tea.Batch(
                        m.refreshSessionGitStatus(msg.sessionID),
                        m.startEventChannelListener(), // Restart listener
                )</span>

        case gitStatusRefreshMsg:<span class="cov0" title="0">
                // Low priority: Working tree changes (polling)
                return m, m.refreshAllGitStatus()</span>

        case tmuxStatusRefreshMsg:<span class="cov0" title="0">
                // Low priority: Tmux status (polling)
                return m, m.refreshTmuxStatus()</span>

        case errorMsg:<span class="cov0" title="0">
                m.lastError = msg.err.Error()
                // Clear error after a few seconds and restart event listener if it was from file watcher
                return m, tea.Batch(
                        tea.Tick(3*time.Second, func(time.Time) tea.Msg </span><span class="cov0" title="0">{
                                return clearErrorMsg{}
                        }</span>),
                        m.startEventChannelListener(), // Restart listener in case error came from file watcher
                )

        case clearErrorMsg:<span class="cov0" title="0">
                m.lastError = ""
                return m, nil</span>

        case clearSuccessMsg:<span class="cov0" title="0">
                m.successMessage = ""
                return m, nil</span>

        case confirmYesMsg:<span class="cov0" title="0">
                if m.confirmDialog != nil &amp;&amp; m.confirmDialog.OnYes != nil </span><span class="cov0" title="0">{
                        cmd := m.confirmDialog.OnYes()
                        m.confirmDialog = nil
                        return m, cmd
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case confirmNoMsg:<span class="cov0" title="0">
                if m.confirmDialog != nil &amp;&amp; m.confirmDialog.OnNo != nil </span><span class="cov0" title="0">{
                        cmd := m.confirmDialog.OnNo()
                        m.confirmDialog = nil
                        return m, cmd
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case showConfirmDialogMsg:<span class="cov0" title="0">
                return m.handleShowConfirmDialog(msg)</span>

        case showNewSessionDialogMsg:<span class="cov0" title="0">
                return m.handleShowNewSessionDialog()</span>

        case newSessionDialogInputMsg:<span class="cov0" title="0">
                return m.handleNewSessionDialogInput(msg.input)</span>

        case newSessionDialogSubmitMsg:<span class="cov0" title="0">
                return m.handleNewSessionDialogSubmit()</span>

        case newSessionDialogCancelMsg:<span class="cov0" title="0">
                return m.handleNewSessionDialogCancel()</span>

        case sessionCreatingMsg:<span class="cov0" title="0">
                // Mark session as being created
                m.creatingSessions[msg.name] = true
                return m, nil</span>

        case sessionCreatedMsg:<span class="cov0" title="0">
                // Remove from creating list, show success message, and refresh
                delete(m.creatingSessions, msg.name)
                m.successMessage = fmt.Sprintf("Session '%s' created successfully", msg.name)
                return m, tea.Batch(
                        m.refreshSessions(),
                        tea.Tick(3*time.Second, func(time.Time) tea.Msg </span><span class="cov0" title="0">{
                                return clearSuccessMsg{}
                        }</span>),
                )

        case sessionCreationFailedMsg:<span class="cov0" title="0">
                // Remove from creating list and show error
                delete(m.creatingSessions, msg.name)
                m.lastError = fmt.Sprintf("Failed to create session '%s': %s", msg.name, msg.err.Error())
                return m, tea.Tick(5*time.Second, func(time.Time) tea.Msg </span><span class="cov0" title="0">{
                        return clearErrorMsg{}
                }</span>)

        case attachRequestMsg:<span class="cov0" title="0">
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("Update: Received attachRequestMsg for session: %s", msg.sessionName)
                }</span>
                // Store the session to attach to and quit
                <span class="cov0" title="0">m.attachOnExit = msg.sessionName
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("Update: Set attachOnExit=%s, calling tea.Quit", msg.sessionName)
                }</span>
                <span class="cov0" title="0">return m, tea.Quit</span>

        case fileWatcherSetupMsg:<span class="cov0" title="0">
                // Store the file watcher in the model
                m.fileWatcher = msg.watcher
                return m, m.startEventChannelListener()</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleKeyPress processes keyboard input
func (m Model) handleKeyPress(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("handleKeyPress: Key pressed: '%s'", msg.String())
        }</span>

        // Handle confirmation dialog first
        <span class="cov0" title="0">if m.confirmDialog != nil </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("handleKeyPress: In confirmation dialog, key: '%s'", msg.String())
                }</span>
                <span class="cov0" title="0">switch msg.String() </span>{
                case "y", "Y", "enter":<span class="cov0" title="0">
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Println("handleKeyPress: Confirmation Yes")
                        }</span>
                        <span class="cov0" title="0">return m, func() tea.Msg </span><span class="cov0" title="0">{ return confirmYesMsg{} }</span>
                case "n", "N", "esc":<span class="cov0" title="0">
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Println("handleKeyPress: Confirmation No")
                        }</span>
                        <span class="cov0" title="0">return m, func() tea.Msg </span><span class="cov0" title="0">{ return confirmNoMsg{} }</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        // Handle new session dialog
        <span class="cov0" title="0">if m.newSessionDialog != nil </span><span class="cov0" title="0">{
                return m.handleNewSessionDialogKeys(msg)
        }</span>

        // Handle help overlay
        <span class="cov0" title="0">if m.showHelp </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("handleKeyPress: In help overlay, key: '%s'", msg.String())
                }</span>
                <span class="cov0" title="0">switch msg.String() </span>{
                case "?", "esc", "q":<span class="cov0" title="0">
                        m.showHelp = false</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        // Handle action keys first (before table navigation)
        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("handleKeyPress: Processing action key: '%s', sessions: %d", msg.String(), len(m.sessions))
        }</span>

        <span class="cov0" title="0">switch msg.String() </span>{
        case "q", "ctrl+c":<span class="cov0" title="0">
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Println("handleKeyPress: Quit requested")
                }</span>
                <span class="cov0" title="0">return m, tea.Quit</span>

        case "enter", "a":<span class="cov0" title="0">
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("handleKeyPress: Attach requested, sessions available: %d", len(m.sessions))
                }</span>
                <span class="cov0" title="0">if len(m.sessions) &gt; 0 </span><span class="cov0" title="0">{
                        sessionID := m.getSelectedSessionID()
                        if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("handleKeyPress: Selected session ID: '%s'", sessionID)
                        }</span>
                        <span class="cov0" title="0">if sessionID == "" </span><span class="cov0" title="0">{
                                if debugLogger != nil </span><span class="cov0" title="0">{
                                        debugLogger.Println("handleKeyPress: No session selected - setting error")
                                }</span>
                                <span class="cov0" title="0">m.lastError = "No session selected"
                                return m, nil</span>
                        }
                        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("handleKeyPress: Processing attach directly for session: %s", sessionID)
                        }</span>

                        // Handle attach directly instead of through a command
                        <span class="cov0" title="0">session := m.findSession(sessionID)
                        if session == nil </span><span class="cov0" title="0">{
                                m.lastError = "Session not found"
                                return m, nil
                        }</span>

                        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("handleKeyPress: Found session %s, IsAlive: %v", session.Core.Name, session.IsAlive)
                        }</span>

                        <span class="cov0" title="0">if !session.IsAlive </span><span class="cov0" title="0">{
                                // Show confirmation dialog for dead sessions
                                if debugLogger != nil </span><span class="cov0" title="0">{
                                        debugLogger.Printf("handleKeyPress: Session %s is dead, showing dialog", session.Core.Name)
                                }</span>
                                <span class="cov0" title="0">m.confirmDialog = &amp;ConfirmDialog{
                                        Message: fmt.Sprintf("Session '%s' tmux is not running. Recreate it?", session.Core.Name),
                                        OnYes: func() tea.Cmd </span><span class="cov0" title="0">{
                                                return m.recreateAndAttach(sessionID)
                                        }</span>,
                                        OnNo: func() tea.Cmd <span class="cov0" title="0">{
                                                return nil
                                        }</span>,
                                }
                                <span class="cov0" title="0">return m, nil</span>
                        }

                        // Alive session - exit and attach
                        <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("handleKeyPress: Session %s is alive, setting attachOnExit", session.Core.Name)
                        }</span>
                        <span class="cov0" title="0">m.attachOnExit = session.Core.TmuxSession
                        return m, tea.Quit</span>
                }
                <span class="cov0" title="0">if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Println("handleKeyPress: No sessions available")
                }</span>
                <span class="cov0" title="0">m.lastError = "No sessions available"
                return m, nil</span>

        case "n":<span class="cov0" title="0">
                return m, func() tea.Msg </span><span class="cov0" title="0">{ return showNewSessionDialogMsg{} }</span>

        case "d":<span class="cov0" title="0">
                if len(m.sessions) &gt; 0 </span><span class="cov0" title="0">{
                        return m, m.confirmDelete(m.getSelectedSessionID())
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "c":<span class="cov0" title="0">
                return m, m.runCleanup()</span>

        case "?":<span class="cov0" title="0">
                m.showHelp = true
                return m, nil</span>

        case "r":<span class="cov0" title="0">
                return m, m.refreshSessions()</span>

        case "s":<span class="cov0" title="0">
                // Switch to session branch
                if len(m.sessions) &gt; 0 </span><span class="cov0" title="0">{
                        return m, m.switchToSessionBranch(m.getSelectedSessionID())
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "m":<span class="cov0" title="0">
                // Merge session changes
                if len(m.sessions) &gt; 0 </span><span class="cov0" title="0">{
                        return m, m.mergeSessionChanges(m.getSelectedSessionID())
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "u":<span class="cov0" title="0">
                // Publish (commit + push) session
                if len(m.sessions) &gt; 0 </span><span class="cov0" title="0">{
                        return m, m.publishSession(m.getSelectedSessionID())
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "t":<span class="cov0" title="0">
                // Toggle between detailed/compact view (placeholder for now)
                return m, nil</span>

        case "/":<span class="cov0" title="0">
                // Search/filter sessions (placeholder for now)
                return m, nil</span>
        }

        // Handle navigation keys for the left panel
        <span class="cov0" title="0">switch msg.String() </span>{
        case "up", "k":<span class="cov0" title="0">
                if m.selectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        m.selectedIndex--
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        case "down", "j":<span class="cov0" title="0">
                totalItems := len(m.sessions) + len(m.creatingSessions)
                if m.selectedIndex &lt; totalItems-1 </span><span class="cov0" title="0">{
                        m.selectedIndex++
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// Session selection helpers
func (m Model) getSelectedSessionID() string <span class="cov0" title="0">{
        if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("getSelectedSessionID: Sessions count: %d, Creating: %d", len(m.sessions), len(m.creatingSessions))
        }</span>

        <span class="cov0" title="0">totalItems := len(m.sessions) + len(m.creatingSessions)
        if totalItems == 0 </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Println("getSelectedSessionID: No sessions available")
                }</span>
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov0" title="0">selectedIdx := m.selectedIndex
        if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("getSelectedSessionID: Selected index: %d", selectedIdx)
        }</span>

        // Check if selecting a creating session
        <span class="cov0" title="0">if selectedIdx &lt; len(m.creatingSessions) </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Println("getSelectedSessionID: Selected creating session, returning empty")
                }</span>
                <span class="cov0" title="0">return ""</span>
        }

        // Adjust for regular sessions
        <span class="cov0" title="0">sessionIndex := selectedIdx - len(m.creatingSessions)
        if sessionIndex &gt;= len(m.sessions) </span><span class="cov0" title="0">{
                if debugLogger != nil </span><span class="cov0" title="0">{
                        debugLogger.Printf("getSelectedSessionID: Adjusted index %d &gt;= sessions %d", sessionIndex, len(m.sessions))
                }</span>
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov0" title="0">sessionID := m.sessions[sessionIndex].Core.ID
        if debugLogger != nil </span><span class="cov0" title="0">{
                debugLogger.Printf("getSelectedSessionID: Returning session ID: %s (name: %s)", sessionID, m.sessions[sessionIndex].Core.Name)
        }</span>

        <span class="cov0" title="0">return sessionID</span>
}

// No longer needed - using custom split-pane layout

// GetAttachOnExit returns the session to attach to when exiting TUI
func (m Model) GetAttachOnExit() string <span class="cov0" title="0">{
        return m.attachOnExit
}</span>

func (m Model) findSession(sessionID string) *types.Session <span class="cov0" title="0">{
        for i := range m.sessions </span><span class="cov0" title="0">{
                if m.sessions[i].Core.ID == sessionID </span><span class="cov0" title="0">{
                        return &amp;m.sessions[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// handleShowConfirmDialog sets up a confirmation dialog
func (m Model) handleShowConfirmDialog(msg showConfirmDialogMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        m.confirmDialog = &amp;ConfirmDialog{
                Message: msg.message,
                OnYes:   msg.onYes,
                OnNo:    msg.onNo,
        }
        return m, nil
}</span>

// handleShowNewSessionDialog sets up a new session dialog
func (m Model) handleShowNewSessionDialog() (Model, tea.Cmd) <span class="cov0" title="0">{
        m.newSessionDialog = &amp;NewSessionDialog{
                NameInput: "",
                Error:     "",
        }
        return m, nil
}</span>

// handleNewSessionDialogKeys handles keyboard input for the new session dialog
func (m Model) handleNewSessionDialogKeys(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        dialog := m.newSessionDialog

        switch msg.String() </span>{
        case "esc":<span class="cov0" title="0">
                return m, func() tea.Msg </span><span class="cov0" title="0">{ return newSessionDialogCancelMsg{} }</span>

        case "enter":<span class="cov0" title="0">
                return m, func() tea.Msg </span><span class="cov0" title="0">{ return newSessionDialogSubmitMsg{} }</span>

        case "backspace":<span class="cov0" title="0">
                if len(dialog.NameInput) &gt; 0 </span><span class="cov0" title="0">{
                        dialog.NameInput = dialog.NameInput[:len(dialog.NameInput)-1]
                }</span>
                // Clear error when user starts typing
                <span class="cov0" title="0">dialog.Error = ""
                return m, nil</span>

        default:<span class="cov0" title="0">
                // Handle regular character input
                if len(msg.String()) == 1 </span><span class="cov0" title="0">{
                        char := msg.String()
                        dialog.NameInput += char
                        // Clear error when user starts typing
                        dialog.Error = ""
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }
}

// handleNewSessionDialogInput handles text input for the dialog
func (m Model) handleNewSessionDialogInput(input string) (Model, tea.Cmd) <span class="cov0" title="0">{
        if m.newSessionDialog != nil </span><span class="cov0" title="0">{
                m.newSessionDialog.NameInput = input
                // Clear error when user types
                m.newSessionDialog.Error = ""
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// handleNewSessionDialogSubmit processes the dialog submission
func (m Model) handleNewSessionDialogSubmit() (Model, tea.Cmd) <span class="cov0" title="0">{
        dialog := m.newSessionDialog
        if dialog == nil </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        // Validate input
        <span class="cov0" title="0">if strings.TrimSpace(dialog.NameInput) == "" </span><span class="cov0" title="0">{
                dialog.Error = "Session name is required"
                return m, nil
        }</span>

        // Check for duplicate session names
        <span class="cov0" title="0">for _, session := range m.sessions </span><span class="cov0" title="0">{
                if session.Core.Name == strings.TrimSpace(dialog.NameInput) </span><span class="cov0" title="0">{
                        dialog.Error = "Session name already exists"
                        return m, nil
                }</span>
        }

        // Create the session
        <span class="cov0" title="0">name := strings.TrimSpace(dialog.NameInput)

        // Clear the dialog
        m.newSessionDialog = nil

        // Create session using state manager
        return m, tea.Batch(
                // Show immediate "creating" status
                func() tea.Msg </span><span class="cov0" title="0">{
                        return sessionCreatingMsg{name: name}
                }</span>,
                // Create session in background
                func() tea.Msg <span class="cov0" title="0">{
                        err := m.stateManager.CreateSession(name)
                        if err != nil </span><span class="cov0" title="0">{
                                return sessionCreationFailedMsg{name: name, err: err}
                        }</span>

                        // Signal completion
                        <span class="cov0" title="0">return sessionCreatedMsg{name: name}</span>
                },
        )
}

// handleNewSessionDialogCancel cancels the dialog
func (m Model) handleNewSessionDialogCancel() (Model, tea.Cmd) <span class="cov0" title="0">{
        m.newSessionDialog = nil
        return m, nil
}</span>

// switchToSessionBranch switches to a session's branch
func (m Model) switchToSessionBranch(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session not found")}
                }</span>

                // Show confirmation dialog
                <span class="cov0" title="0">return showConfirmDialogMsg{
                        message: fmt.Sprintf("Switch to session '%s' branch?", session.Core.Name),
                        onYes: func() tea.Cmd </span><span class="cov0" title="0">{
                                return func() tea.Msg </span><span class="cov0" title="0">{
                                        // Execute cwt switch command
                                        if err := executeCommand("cwt", "switch", session.Core.Name); err != nil </span><span class="cov0" title="0">{
                                                return errorMsg{err: fmt.Errorf("failed to switch: %w", err)}
                                        }</span>
                                        <span class="cov0" title="0">m.successMessage = fmt.Sprintf("Switched to session '%s' branch", session.Core.Name)
                                        return clearSuccessMsg{}</span>
                                }
                        },
                        onNo: func() tea.Cmd <span class="cov0" title="0">{ return nil }</span>,
                }
        }
}

// mergeSessionChanges merges a session's changes
func (m Model) mergeSessionChanges(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session not found")}
                }</span>

                <span class="cov0" title="0">if !session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session '%s' has no changes to merge", session.Core.Name)}
                }</span>

                // Show confirmation dialog
                <span class="cov0" title="0">return showConfirmDialogMsg{
                        message: fmt.Sprintf("Merge session '%s' into current branch?", session.Core.Name),
                        onYes: func() tea.Cmd </span><span class="cov0" title="0">{
                                return func() tea.Msg </span><span class="cov0" title="0">{
                                        // Execute cwt merge command
                                        if err := executeCommand("cwt", "merge", session.Core.Name); err != nil </span><span class="cov0" title="0">{
                                                return errorMsg{err: fmt.Errorf("failed to merge: %w", err)}
                                        }</span>
                                        <span class="cov0" title="0">m.successMessage = fmt.Sprintf("Merged session '%s'", session.Core.Name)
                                        return clearSuccessMsg{}</span>
                                }
                        },
                        onNo: func() tea.Cmd <span class="cov0" title="0">{ return nil }</span>,
                }
        }
}

// publishSession publishes a session (commit + push)
func (m Model) publishSession(sessionID string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                session := m.findSession(sessionID)
                if session == nil </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session not found")}
                }</span>

                <span class="cov0" title="0">if !session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                        return errorMsg{err: fmt.Errorf("session '%s' has no changes to publish", session.Core.Name)}
                }</span>

                // Show confirmation dialog
                <span class="cov0" title="0">return showConfirmDialogMsg{
                        message: fmt.Sprintf("Publish session '%s' (commit + push)?", session.Core.Name),
                        onYes: func() tea.Cmd </span><span class="cov0" title="0">{
                                return func() tea.Msg </span><span class="cov0" title="0">{
                                        // Execute cwt publish command
                                        if err := executeCommand("cwt", "publish", session.Core.Name); err != nil </span><span class="cov0" title="0">{
                                                return errorMsg{err: fmt.Errorf("failed to publish: %w", err)}
                                        }</span>
                                        <span class="cov0" title="0">m.successMessage = fmt.Sprintf("Published session '%s'", session.Core.Name)
                                        return clearSuccessMsg{}</span>
                                }
                        },
                        onNo: func() tea.Cmd <span class="cov0" title="0">{ return nil }</span>,
                }
        }
}

// executeCommand executes a shell command
func executeCommand(command string, args ...string) error <span class="cov0" title="0">{
        cmd := exec.Command(command, args...)
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package tui

import (
        "fmt"
        "log"
        "os"
        "os/exec"

        tea "github.com/charmbracelet/bubbletea"

        "github.com/jlaneve/cwt-cli/internal/state"
)

// Run starts the TUI with the given state manager, creating a seamless loop
func Run(stateManager *state.Manager) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                // Create the TUI model
                model, err := NewModel(stateManager)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create TUI model: %w", err)
                }</span>

                // Configure the program
                <span class="cov0" title="0">p := tea.NewProgram(
                        model,
                        tea.WithAltScreen(),       // Use alternate screen buffer
                        tea.WithMouseCellMotion(), // Enable mouse support
                )

                // Run the program
                finalModel, err := p.Run()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("TUI error: %w", err)
                }</span>

                // Check if we need to attach to a session after TUI exit
                <span class="cov0" title="0">if m, ok := finalModel.(Model); ok </span><span class="cov0" title="0">{
                        if sessionName := m.GetAttachOnExit(); sessionName != "" </span><span class="cov0" title="0">{
                                // Create logger for this function (reuse same log file)
                                logFile, err := os.OpenFile("cwt-tui-debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                                if err == nil </span><span class="cov0" title="0">{
                                        logger := log.New(logFile, "[TUI-DEBUG] ", log.LstdFlags|log.Lshortfile)
                                        logger.Printf("Run: TUI exited with attachOnExit: %s", sessionName)
                                        logger.Printf("Run: Calling attachToTmuxSession")
                                        logFile.Close()
                                }</span>

                                // Attach to tmux session
                                <span class="cov0" title="0">if err := attachToTmuxSession(sessionName); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                // When tmux exits, show transition message and restart TUI
                                <span class="cov0" title="0">fmt.Println("\nüîÑ Tmux session ended. Returning to CWT dashboard...")

                                // Continue the loop to restart TUI
                                continue</span>
                        }
                }

                // If we get here, user quit TUI without attaching - exit the loop
                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// attachToTmuxSession attaches to a tmux session
func attachToTmuxSession(sessionName string) error <span class="cov0" title="0">{
        cmd := exec.Command("tmux", "attach-session", "-t", sessionName)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach to tmux session '%s': %w", sessionName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package tui

import (
        "fmt"
        "strings"
        "time"

        "github.com/charmbracelet/lipgloss"

        "github.com/jlaneve/cwt-cli/internal/types"
)

// Minimal styles for the TUI
var (
        headerStyle = lipgloss.NewStyle().
                        Bold(true).
                        Margin(0, 0, 1, 0)

        actionsStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240")).
                        Margin(1, 0, 0, 0)

        helpStyle = lipgloss.NewStyle().
                        Border(lipgloss.NormalBorder()).
                        Padding(1, 2).
                        Margin(1, 2)

        confirmStyle = lipgloss.NewStyle().
                        Border(lipgloss.NormalBorder()).
                        Padding(1, 2).
                        Margin(2, 4)

        errorStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("9")).
                        Bold(true)

        // Simple status colors
        waitingStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
        workingStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("6"))
        deadStyle    = lipgloss.NewStyle().Foreground(lipgloss.Color("1"))
        aliveStyle   = lipgloss.NewStyle().Foreground(lipgloss.Color("2"))
        changesStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
        cleanStyle   = lipgloss.NewStyle().Foreground(lipgloss.Color("8"))
        idleStyle    = lipgloss.NewStyle().Foreground(lipgloss.Color("8"))
)

// View renders the entire TUI
func (m Model) View() string <span class="cov0" title="0">{
        if !m.ready </span><span class="cov0" title="0">{
                return "Loading sessions..."
        }</span>

        // HEADER - Dashboard info
        <span class="cov0" title="0">header := m.renderHeader()

        // Calculate exact middle height (no separate status area now)
        middleHeight := m.height - 5 - 1 // header=3, actions=1

        // MIDDLE PANEL - Combined left and right panels
        middle := m.renderMiddlePanel(m.width, middleHeight)

        // ACTIONS BAR - Navigation help
        actions := m.renderActions()

        // Assemble everything
        content := lipgloss.JoinVertical(
                lipgloss.Left,
                header,
                middle,
                actions,
        )

        // Overlay dialogs
        if m.confirmDialog != nil </span><span class="cov0" title="0">{
                return m.renderWithConfirmDialog(content)
        }</span>

        <span class="cov0" title="0">if m.newSessionDialog != nil </span><span class="cov0" title="0">{
                return m.renderWithNewSessionDialog(content)
        }</span>

        <span class="cov0" title="0">if m.showHelp </span><span class="cov0" title="0">{
                return m.renderWithHelp(content)
        }</span>

        <span class="cov0" title="0">return content</span>
}

// renderHeader renders the dashboard header with summary info
func (m Model) renderHeader() string <span class="cov0" title="0">{
        totalSessions := len(m.sessions)
        activeSessions := 0
        needsAttention := 0

        for _, session := range m.sessions </span><span class="cov0" title="0">{
                if session.IsAlive </span><span class="cov0" title="0">{
                        activeSessions++
                }</span>
                <span class="cov0" title="0">if session.ClaudeStatus.State == types.ClaudeWaiting </span><span class="cov0" title="0">{
                        needsAttention++
                }</span>
        }

        <span class="cov0" title="0">summary := fmt.Sprintf("CWT Dashboard - %d sessions, %d active", totalSessions, activeSessions)
        if needsAttention &gt; 0 </span><span class="cov0" title="0">{
                summary += fmt.Sprintf(", %d need attention", needsAttention)
        }</span>

        // Header with proper styling and natural height
        <span class="cov0" title="0">return lipgloss.NewStyle().
                Bold(true).
                Width(m.width).
                Padding(1).
                Height(3). // one line plus top + bottom padding
                Render(summary)</span>
}

// renderMiddlePanel renders the combined left and right panels
func (m Model) renderMiddlePanel(width int, height int) string <span class="cov0" title="0">{
        statusHeight := 0

        // if we need to render the status area, we need to account for it in the height
        if m.lastError != "" || m.successMessage != "" </span><span class="cov0" title="0">{
                statusHeight = 2 // Reserve 2 lines for status messages
        }</span>

        <span class="cov0" title="0">height -= statusHeight

        // LEFT PANEL - Session list with border
        leftPanel := m.renderLeftPanel(40, height)

        // RIGHT PANEL - Session details with border (includes status area at bottom)
        rightPanel := m.renderRightPanel(width-40-1, height)

        middleSection := lipgloss.JoinHorizontal(lipgloss.Top, leftPanel, " ", rightPanel)

        if statusHeight &gt; 0 </span><span class="cov0" title="0">{
                // render the status area
                statusArea := m.renderStatusArea()
                middleSection = lipgloss.JoinVertical(lipgloss.Top, middleSection, statusArea)
        }</span>

        // Assemble middle section
        <span class="cov0" title="0">return middleSection</span>
}

// renderLeftPanel renders the session list on the left side
func (m Model) renderLeftPanel(width int, height int) string <span class="cov0" title="0">{
        totalItems := len(m.sessions) + len(m.creatingSessions)
        if totalItems == 0 </span><span class="cov0" title="0">{
                content := "No sessions found.\n\nPress 'n' to create a new session."
                return lipgloss.NewStyle().
                        Width(width).
                        Height(height).
                        Border(lipgloss.NormalBorder()).
                        Padding(1).
                        Render(content)
        }</span>

        <span class="cov0" title="0">var lines []string
        lines = append(lines, "Sessions:")
        lines = append(lines, "")

        // Track current item index for selection
        itemIndex := 0

        // Show creating sessions first
        for name := range m.creatingSessions </span><span class="cov0" title="0">{
                // Selection indicator on the far left
                var selectionIndicator string
                if itemIndex == m.selectedIndex </span><span class="cov0" title="0">{
                        selectionIndicator = "‚ñ∂"
                }</span> else<span class="cov0" title="0"> {
                        selectionIndicator = " "
                }</span>

                // Creating indicator
                <span class="cov0" title="0">creatingIndicator := workingStyle.Render("‚óè")

                // Session name with creating status
                sessionName := name + " (creating...)"

                // Build the session line
                sessionPart := fmt.Sprintf("%s %s %s", selectionIndicator, creatingIndicator, sessionName)

                // Calculate spacing - no git indicator for creating sessions
                contentWidth := width - 4                             // Account for border and padding
                sessionPartVisual := 1 + 1 + 1 + 1 + len(sessionName) // selection + space + indicator + space + name

                spacesNeeded := contentWidth - sessionPartVisual
                if spacesNeeded &lt; 0 </span><span class="cov0" title="0">{
                        spacesNeeded = 0
                }</span>

                <span class="cov0" title="0">line := sessionPart + strings.Repeat(" ", spacesNeeded)
                lines = append(lines, line)
                itemIndex++</span>
        }

        // Show existing sessions
        <span class="cov0" title="0">for _, session := range m.sessions </span><span class="cov0" title="0">{
                // Selection indicator on the far left
                var selectionIndicator string
                if itemIndex == m.selectedIndex </span><span class="cov0" title="0">{
                        selectionIndicator = "‚ñ∂"
                }</span> else<span class="cov0" title="0"> {
                        selectionIndicator = " "
                }</span>

                // Claude status indicator
                <span class="cov0" title="0">claudeIndicator := getClaudeIndicator(session.ClaudeStatus.State)

                // Session name with tmux status
                name := session.Core.Name
                if !session.IsAlive </span><span class="cov0" title="0">{
                        name += " (closed)"
                }</span>

                // Git changes indicator on the right
                <span class="cov0" title="0">gitIndicator := getGitIndicator(session.GitStatus)

                // Build the session part with selection and claude indicators
                sessionPart := fmt.Sprintf("%s %s %s", selectionIndicator, claudeIndicator, name)

                // Calculate spacing for right-aligned git indicator
                contentWidth := width - 4                      // Account for border and padding
                sessionPartVisual := 1 + 1 + 1 + 1 + len(name) // selection + space + claude + space + name
                gitIndicatorVisual := getGitIndicatorVisualLength(session.GitStatus)

                spacesNeeded := contentWidth - sessionPartVisual - gitIndicatorVisual
                if spacesNeeded &lt; 1 </span><span class="cov0" title="0">{
                        spacesNeeded = 1
                }</span>

                <span class="cov0" title="0">line := sessionPart + strings.Repeat(" ", spacesNeeded) + gitIndicator
                lines = append(lines, line)
                itemIndex++</span>
        }

        <span class="cov0" title="0">content := strings.Join(lines, "\n")

        return lipgloss.NewStyle().
                Width(width).
                Height(height).
                Border(lipgloss.NormalBorder()).
                Padding(1).
                Render(content)</span>
}

// renderRightPanel renders the detailed view of the selected session
func (m Model) renderRightPanel(width int, height int) string <span class="cov0" title="0">{
        totalItems := len(m.sessions) + len(m.creatingSessions)
        if totalItems == 0 || m.selectedIndex &gt;= totalItems </span><span class="cov0" title="0">{
                var lines []string
                lines = append(lines, "No session selected")

                // Add status area at the bottom
                if m.lastError != "" </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                        lines = append(lines, "---")
                        // Use the same 2-line error rendering logic
                        errorLines := m.renderErrorMessageForPanel(width - 6)
                        lines = append(lines, errorLines...)
                }</span> else<span class="cov0" title="0"> if m.successMessage != "" </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                        lines = append(lines, "---")
                        successMsg := "‚úì " + sanitizeMessage(m.successMessage)
                        maxWidth := width - 6 // Account for border, padding, and prefix
                        if len(successMsg) &gt; maxWidth </span><span class="cov0" title="0">{
                                successMsg = successMsg[:maxWidth-3] + "..."
                        }</span>
                        <span class="cov0" title="0">successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("2")) // Green
                        lines = append(lines, successStyle.Render(successMsg))</span>
                }

                <span class="cov0" title="0">content := strings.Join(lines, "\n")
                return lipgloss.NewStyle().
                        Width(width).
                        Height(height).
                        Border(lipgloss.NormalBorder()).
                        Padding(1).
                        Render(content)</span>
        }

        // Check if we're selecting a creating session
        <span class="cov0" title="0">if m.selectedIndex &lt; len(m.creatingSessions) </span><span class="cov0" title="0">{
                // Get the creating session name (map iteration order isn't guaranteed, but for display it's okay)
                var creatingName string
                i := 0
                for name := range m.creatingSessions </span><span class="cov0" title="0">{
                        if i == m.selectedIndex </span><span class="cov0" title="0">{
                                creatingName = name
                                break</span>
                        }
                        <span class="cov0" title="0">i++</span>
                }

                <span class="cov0" title="0">var lines []string
                lines = append(lines, fmt.Sprintf("Session: %s", creatingName))
                lines = append(lines, "")
                lines = append(lines, "Status: Creating session...")
                lines = append(lines, "")
                lines = append(lines, "Please wait while the session is being set up with:")
                lines = append(lines, "‚Ä¢ Git worktree")
                lines = append(lines, "‚Ä¢ Claude configuration")
                lines = append(lines, "‚Ä¢ Tmux session")

                // Add status area at the bottom
                if m.lastError != "" </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                        lines = append(lines, "---")
                        // Use the same 2-line error rendering logic
                        errorLines := m.renderErrorMessageForPanel(width - 6)
                        lines = append(lines, errorLines...)
                }</span> else<span class="cov0" title="0"> if m.successMessage != "" </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                        lines = append(lines, "---")
                        successMsg := "‚úì " + sanitizeMessage(m.successMessage)
                        maxWidth := width - 6 // Account for border, padding, and prefix
                        if len(successMsg) &gt; maxWidth </span><span class="cov0" title="0">{
                                successMsg = successMsg[:maxWidth-3] + "..."
                        }</span>
                        <span class="cov0" title="0">successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("2")) // Green
                        lines = append(lines, successStyle.Render(successMsg))</span>
                }

                <span class="cov0" title="0">content := strings.Join(lines, "\n")
                return lipgloss.NewStyle().
                        Width(width).
                        Height(height).
                        Border(lipgloss.NormalBorder()).
                        Padding(1).
                        Render(content)</span>
        }

        // Regular session - adjust index to account for creating sessions
        <span class="cov0" title="0">sessionIndex := m.selectedIndex - len(m.creatingSessions)
        if sessionIndex &gt;= len(m.sessions) </span><span class="cov0" title="0">{
                var lines []string
                lines = append(lines, "Session not found")

                // Add status area at the bottom
                if m.lastError != "" </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                        lines = append(lines, "---")
                        // Use the same 2-line error rendering logic
                        errorLines := m.renderErrorMessageForPanel(width - 6)
                        lines = append(lines, errorLines...)
                }</span> else<span class="cov0" title="0"> if m.successMessage != "" </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                        lines = append(lines, "---")
                        successMsg := "‚úì " + sanitizeMessage(m.successMessage)
                        maxWidth := width - 6 // Account for border, padding, and prefix
                        if len(successMsg) &gt; maxWidth </span><span class="cov0" title="0">{
                                successMsg = successMsg[:maxWidth-3] + "..."
                        }</span>
                        <span class="cov0" title="0">successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("2")) // Green
                        lines = append(lines, successStyle.Render(successMsg))</span>
                }

                <span class="cov0" title="0">content := strings.Join(lines, "\n")
                return lipgloss.NewStyle().
                        Width(width).
                        Height(height).
                        Border(lipgloss.NormalBorder()).
                        Padding(1).
                        Render(content)</span>
        }

        <span class="cov0" title="0">session := m.sessions[sessionIndex]

        var lines []string
        lines = append(lines, fmt.Sprintf("Session: %s", session.Core.Name))
        lines = append(lines, fmt.Sprintf("ID: %s", session.Core.ID))
        lines = append(lines, fmt.Sprintf("Created: %s", session.Core.CreatedAt.Format("2006-01-02 15:04:05")))
        lines = append(lines, "")

        // Tmux status
        tmuxStatus := "alive"
        if !session.IsAlive </span><span class="cov0" title="0">{
                tmuxStatus = deadStyle.Render("dead")
        }</span> else<span class="cov0" title="0"> {
                tmuxStatus = aliveStyle.Render("alive")
        }</span>
        <span class="cov0" title="0">lines = append(lines, fmt.Sprintf("Tmux: %s (%s)", tmuxStatus, session.Core.TmuxSession))
        lines = append(lines, "")

        // Claude status
        claudeStatus := formatClaudeStatusDetail(session.ClaudeStatus)
        lines = append(lines, fmt.Sprintf("Claude: %s", claudeStatus))
        if session.ClaudeStatus.StatusMessage != "" </span><span class="cov0" title="0">{
                lines = append(lines, fmt.Sprintf("Message: %s", session.ClaudeStatus.StatusMessage))
        }</span>
        <span class="cov0" title="0">if !session.ClaudeStatus.LastMessage.IsZero() </span><span class="cov0" title="0">{
                lines = append(lines, fmt.Sprintf("Last activity: %s", formatActivity(session.ClaudeStatus.LastMessage)))
        }</span>
        <span class="cov0" title="0">lines = append(lines, "")

        // Git status
        gitStatus := "clean"
        if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                gitStatus = changesStyle.Render("has changes")
        }</span> else<span class="cov0" title="0"> {
                gitStatus = cleanStyle.Render("clean")
        }</span>
        <span class="cov0" title="0">lines = append(lines, fmt.Sprintf("Git: %s", gitStatus))

        if session.GitStatus.HasChanges </span><span class="cov0" title="0">{
                // Calculate available width for file names (account for border, padding, and git prefix)
                availableWidth := width - 10 // Border(2) + Padding(2) + Indentation(4) + GitPrefix(2)

                if len(session.GitStatus.ModifiedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        lines = append(lines, fmt.Sprintf("  Modified (%d):", len(session.GitStatus.ModifiedFiles)))
                        for _, file := range session.GitStatus.ModifiedFiles </span><span class="cov0" title="0">{
                                displayFile := truncateFileName(file, availableWidth)
                                lines = append(lines, fmt.Sprintf("    M %s", displayFile))
                        }</span>
                }
                <span class="cov0" title="0">if len(session.GitStatus.AddedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        lines = append(lines, fmt.Sprintf("  Added (%d):", len(session.GitStatus.AddedFiles)))
                        for _, file := range session.GitStatus.AddedFiles </span><span class="cov0" title="0">{
                                displayFile := truncateFileName(file, availableWidth)
                                lines = append(lines, fmt.Sprintf("    A %s", displayFile))
                        }</span>
                }
                <span class="cov0" title="0">if len(session.GitStatus.DeletedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        lines = append(lines, fmt.Sprintf("  Deleted (%d):", len(session.GitStatus.DeletedFiles)))
                        for _, file := range session.GitStatus.DeletedFiles </span><span class="cov0" title="0">{
                                displayFile := truncateFileName(file, availableWidth)
                                lines = append(lines, fmt.Sprintf("    D %s", displayFile))
                        }</span>
                }
                <span class="cov0" title="0">if len(session.GitStatus.UntrackedFiles) &gt; 0 </span><span class="cov0" title="0">{
                        lines = append(lines, fmt.Sprintf("  Untracked (%d):", len(session.GitStatus.UntrackedFiles)))
                        for _, file := range session.GitStatus.UntrackedFiles </span><span class="cov0" title="0">{
                                displayFile := truncateFileName(file, availableWidth)
                                lines = append(lines, fmt.Sprintf("    ? %s", displayFile))
                        }</span>
                }
        }

        <span class="cov0" title="0">lines = append(lines, "")
        lines = append(lines, fmt.Sprintf("Worktree: %s", session.Core.WorktreePath))

        content := strings.Join(lines, "\n")

        return lipgloss.NewStyle().
                Width(width).
                Height(height).
                Border(lipgloss.NormalBorder()).
                Padding(1).
                Render(content)</span>
}

// renderStatusArea renders the status/notification area between main content and actions
// Now supports up to 2 lines for error messages
func (m Model) renderStatusArea() string <span class="cov0" title="0">{
        if m.lastError != "" </span><span class="cov0" title="0">{
                return m.renderErrorMessage()
        }</span> else<span class="cov0" title="0"> if m.successMessage != "" </span><span class="cov0" title="0">{
                return m.renderSuccessMessage()
        }</span>
        // Return empty string to maintain spacing
        <span class="cov0" title="0">return ""</span>
}

// renderErrorMessage handles error message rendering with 2-line support
func (m Model) renderErrorMessage() string <span class="cov0" title="0">{
        maxWidth := m.width - 10       // Leave some margin
        errorMsg := "‚úó " + m.lastError // Don't sanitize - preserve newlines for wrapping

        // Split message into words for intelligent wrapping
        words := strings.Fields(errorMsg)
        if len(words) == 0 </span><span class="cov0" title="0">{
                return errorStyle.Height(2).Render("‚úó Error")
        }</span>

        <span class="cov0" title="0">var lines []string
        currentLine := ""

        for _, word := range words </span><span class="cov0" title="0">{
                // Check if adding this word would exceed the width
                testLine := currentLine
                if testLine != "" </span><span class="cov0" title="0">{
                        testLine += " "
                }</span>
                <span class="cov0" title="0">testLine += word

                if len(testLine) &lt;= maxWidth </span><span class="cov0" title="0">{
                        currentLine = testLine
                }</span> else<span class="cov0" title="0"> {
                        // Start new line if we have room for 2 lines
                        if len(lines) &lt; 1 </span><span class="cov0" title="0">{
                                lines = append(lines, currentLine)
                                currentLine = word
                        }</span> else<span class="cov0" title="0"> {
                                // Truncate if we're already at 2 lines
                                if len(currentLine)+4 &lt;= maxWidth </span><span class="cov0" title="0">{ // +4 for "..."
                                        currentLine += "..."
                                }</span> else<span class="cov0" title="0"> {
                                        currentLine = currentLine[:maxWidth-3] + "..."
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Add the last line if it has content
        <span class="cov0" title="0">if currentLine != "" </span><span class="cov0" title="0">{
                lines = append(lines, currentLine)
        }</span>

        // Ensure we have exactly 2 lines for consistent spacing
        <span class="cov0" title="0">for len(lines) &lt; 2 </span><span class="cov0" title="0">{
                lines = append(lines, "")
        }</span>

        <span class="cov0" title="0">errorText := strings.Join(lines, "\n")
        return errorStyle.Height(2).Render(errorText)</span>
}

// renderSuccessMessage handles success message rendering (still 1 line)
func (m Model) renderSuccessMessage() string <span class="cov0" title="0">{
        // Keep success messages as single line
        maxWidth := m.width - 10 // Leave some margin
        successMsg := "‚úì " + sanitizeMessage(m.successMessage)
        if len(successMsg) &gt; maxWidth </span><span class="cov0" title="0">{
                successMsg = successMsg[:maxWidth-3] + "..."
        }</span>
        <span class="cov0" title="0">successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("2")) // Green
        // Use 2 lines for consistent spacing with error messages
        return successStyle.Height(2).Render(successMsg)</span>
}

// renderErrorMessageForPanel renders error message for right panel with 2-line support
func (m Model) renderErrorMessageForPanel(maxWidth int) []string <span class="cov0" title="0">{
        errorMsg := "‚úó " + m.lastError

        // Split message into words for intelligent wrapping
        words := strings.Fields(errorMsg)
        if len(words) == 0 </span><span class="cov0" title="0">{
                return []string{errorStyle.Render("‚úó Error"), ""}
        }</span>

        <span class="cov0" title="0">var lines []string
        currentLine := ""

        for _, word := range words </span><span class="cov0" title="0">{
                // Check if adding this word would exceed the width
                testLine := currentLine
                if testLine != "" </span><span class="cov0" title="0">{
                        testLine += " "
                }</span>
                <span class="cov0" title="0">testLine += word

                if len(testLine) &lt;= maxWidth </span><span class="cov0" title="0">{
                        currentLine = testLine
                }</span> else<span class="cov0" title="0"> {
                        // Start new line if we have room for 2 lines
                        if len(lines) &lt; 1 </span><span class="cov0" title="0">{
                                lines = append(lines, errorStyle.Render(currentLine))
                                currentLine = word
                        }</span> else<span class="cov0" title="0"> {
                                // Truncate if we're already at 2 lines
                                if len(currentLine)+4 &lt;= maxWidth </span><span class="cov0" title="0">{ // +4 for "..."
                                        currentLine += "..."
                                }</span> else<span class="cov0" title="0"> {
                                        currentLine = currentLine[:maxWidth-3] + "..."
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Add the last line if it has content
        <span class="cov0" title="0">if currentLine != "" </span><span class="cov0" title="0">{
                lines = append(lines, errorStyle.Render(currentLine))
        }</span>

        // Ensure we have exactly 2 lines for consistent spacing
        <span class="cov0" title="0">for len(lines) &lt; 2 </span><span class="cov0" title="0">{
                lines = append(lines, "")
        }</span>

        <span class="cov0" title="0">return lines</span>
}

// sanitizeMessage removes newlines and other problematic characters for single-line display
func sanitizeMessage(msg string) string <span class="cov0" title="0">{
        // Replace newlines and carriage returns with spaces
        msg = strings.ReplaceAll(msg, "\n", " ")
        msg = strings.ReplaceAll(msg, "\r", " ")

        // Replace multiple spaces with single space
        msg = strings.Join(strings.Fields(msg), " ")

        return msg
}</span>

// renderActions renders the action bar at the bottom
func (m Model) renderActions() string <span class="cov0" title="0">{
        content := "‚Üë‚Üì: navigate  a/enter: attach  s: switch  m: merge  u: publish  n: new  d: delete  c: cleanup  r: refresh  ?: help  q: quit"
        return lipgloss.NewStyle().
                Height(1).
                Width(m.width).
                Foreground(lipgloss.Color("240")).
                Render(content)
}</span>

// renderWithConfirmDialog renders content with a confirmation dialog overlay
func (m Model) renderWithConfirmDialog(content string) string <span class="cov0" title="0">{
        dialog := fmt.Sprintf("%s\n\n[Y]es / [Enter] / [N]o", m.confirmDialog.Message)
        dialogBox := confirmStyle.Render(dialog)

        // Center the dialog on a clean screen
        return lipgloss.Place(
                m.width, m.height,
                lipgloss.Center, lipgloss.Center,
                dialogBox,
        )
}</span>

// renderWithNewSessionDialog renders content with a new session dialog on clean screen
func (m Model) renderWithNewSessionDialog(content string) string <span class="cov0" title="0">{
        dialog := m.newSessionDialog

        var lines []string
        lines = append(lines, "Create New Session")
        lines = append(lines, "")

        // Name field
        lines = append(lines, "Name:")

        nameValue := dialog.NameInput + "_" // Show cursor
        lines = append(lines, nameValue)
        lines = append(lines, "")

        // Show error if present
        if dialog.Error != "" </span><span class="cov0" title="0">{
                lines = append(lines, errorStyle.Render("Error: "+dialog.Error))
                lines = append(lines, "")
        }</span>

        // Instructions
        <span class="cov0" title="0">lines = append(lines, "Enter: create  Esc: cancel")

        dialogText := strings.Join(lines, "\n")
        dialogBox := confirmStyle.Render(dialogText)

        // Center the dialog on a clean screen
        return lipgloss.Place(
                m.width, m.height,
                lipgloss.Center, lipgloss.Center,
                dialogBox,
        )</span>
}

// Removed complex toast overlay system in favor of simpler status area

// renderWithHelp renders content with help overlay
func (m Model) renderWithHelp(content string) string <span class="cov0" title="0">{
        helpText := `CWT Dashboard Help

Navigation:
  ‚Üë/k       Move up
  ‚Üì/j       Move down
  Enter/a   Attach to session
  
Session Actions:
  s         Switch to session branch
  m         Merge session into current branch
  u         Publish session (commit + push)
  
Management:
  n         Create new session
  d         Delete session
  c         Cleanup orphaned resources
  r         Refresh session list
  ?         Toggle this help
  q         Quit

Session Status:
  üü¢ alive    Tmux session running
  üî¥ dead     Tmux session stopped
  üîî needs input  Claude waiting for response
  üîÑ working  Claude actively processing
  ‚úÖ complete Claude task finished
  üìù changes  Git working tree has changes
  ‚ú® clean    Git working tree clean

Press ? or Esc to close help`

        helpBox := helpStyle.Render(helpText)

        // Center the help on a clean screen
        return lipgloss.Place(
                m.width, m.height,
                lipgloss.Center, lipgloss.Center,
                helpBox,
        )
}</span>

// Status formatting functions
func formatTmuxStatus(isAlive bool) string <span class="cov0" title="0">{
        if isAlive </span><span class="cov0" title="0">{
                return aliveStyle.Render("alive")
        }</span>
        <span class="cov0" title="0">return deadStyle.Render("dead")</span>
}

func formatClaudeStatus(status types.ClaudeStatus) string <span class="cov0" title="0">{
        switch status.State </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                return workingStyle.Render("working")</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                // Show truncated message if available
                if status.StatusMessage != "" </span><span class="cov0" title="0">{
                        msg := status.StatusMessage
                        if len(msg) &gt; 30 </span><span class="cov0" title="0">{
                                msg = msg[:27] + "..."
                        }</span>
                        <span class="cov0" title="0">return waitingStyle.Render(msg)</span>
                }
                <span class="cov0" title="0">return waitingStyle.Render("waiting")</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                return "complete"</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                return idleStyle.Render("idle")</span>
        default:<span class="cov0" title="0">
                return idleStyle.Render("unknown")</span>
        }
}

func formatGitStatus(status types.GitStatus) string <span class="cov0" title="0">{
        if status.HasChanges </span><span class="cov0" title="0">{
                return changesStyle.Render("changes")
        }</span>
        <span class="cov0" title="0">return cleanStyle.Render("clean")</span>
}

func formatActivity(lastActivity time.Time) string <span class="cov0" title="0">{
        if lastActivity.IsZero() </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">age := time.Since(lastActivity)
        if age &lt; time.Minute </span><span class="cov0" title="0">{
                return "just now"
        }</span>
        <span class="cov0" title="0">if age &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(age.Minutes())
                return fmt.Sprintf("%dm ago", minutes)
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(age.Hours())
                return fmt.Sprintf("%dh ago", hours)
        }</span>
        <span class="cov0" title="0">days := int(age.Hours() / 24)
        return fmt.Sprintf("%dd ago", days)</span>
}

// Helper functions for split-pane layout

func getClaudeIndicator(state types.ClaudeState) string <span class="cov0" title="0">{
        switch state </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                return workingStyle.Render("‚óè")</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                return waitingStyle.Render("‚óê")</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                return "‚óâ"</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                return idleStyle.Render("‚óã")</span>
        default:<span class="cov0" title="0">
                return idleStyle.Render("‚óã")</span>
        }
}

func getGitIndicator(status types.GitStatus) string <span class="cov0" title="0">{
        if !status.HasChanges </span><span class="cov0" title="0">{
                return cleanStyle.Render("‚ó¶")
        }</span>

        // Calculate total changes
        <span class="cov0" title="0">total := len(status.ModifiedFiles) + len(status.AddedFiles) + len(status.DeletedFiles) + len(status.UntrackedFiles)
        if total == 0 </span><span class="cov0" title="0">{
                return cleanStyle.Render("‚ó¶")
        }</span>

        <span class="cov0" title="0">return changesStyle.Render(fmt.Sprintf("+%d", total))</span>
}

func formatClaudeStatusDetail(status types.ClaudeStatus) string <span class="cov0" title="0">{
        switch status.State </span>{
        case types.ClaudeWorking:<span class="cov0" title="0">
                return workingStyle.Render("working")</span>
        case types.ClaudeWaiting:<span class="cov0" title="0">
                return waitingStyle.Render("waiting for input")</span>
        case types.ClaudeComplete:<span class="cov0" title="0">
                return "complete"</span>
        case types.ClaudeIdle:<span class="cov0" title="0">
                return idleStyle.Render("idle")</span>
        default:<span class="cov0" title="0">
                return idleStyle.Render("unknown")</span>
        }
}

func getGitIndicatorVisualLength(status types.GitStatus) int <span class="cov0" title="0">{
        if !status.HasChanges </span><span class="cov0" title="0">{
                return 1 // "‚ó¶"
        }</span>

        // Calculate total changes
        <span class="cov0" title="0">total := len(status.ModifiedFiles) + len(status.AddedFiles) + len(status.DeletedFiles) + len(status.UntrackedFiles)
        if total == 0 </span><span class="cov0" title="0">{
                return 1 // "‚ó¶"
        }</span>

        // "+N" where N is the number
        <span class="cov0" title="0">return len(fmt.Sprintf("+%d", total))</span>
}

// truncateFileName intelligently truncates file names to fit within available width
func truncateFileName(filename string, maxWidth int) string <span class="cov0" title="0">{
        if len(filename) &lt;= maxWidth </span><span class="cov0" title="0">{
                return filename
        }</span>

        // If the filename is too long, show the beginning and end with "..." in the middle
        <span class="cov0" title="0">if maxWidth &lt; 10 </span><span class="cov0" title="0">{
                // If very narrow, just truncate with ...
                if maxWidth &lt; 4 </span><span class="cov0" title="0">{
                        return "..."
                }</span>
                <span class="cov0" title="0">return filename[:maxWidth-3] + "..."</span>
        }

        // For longer filenames, show beginning and end
        <span class="cov0" title="0">prefixLen := (maxWidth - 3) / 2
        suffixLen := maxWidth - 3 - prefixLen

        return filename[:prefixLen] + "..." + filename[len(filename)-suffixLen:]</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package types

// Event represents all possible events in the system
type Event interface {
        EventType() string
}

// Immediate Events - triggered by user actions for instant UI feedback

// SessionCreationStarted is emitted when session creation begins
type SessionCreationStarted struct {
        Name string `json:"name"`
}

func (e SessionCreationStarted) EventType() string <span class="cov8" title="1">{ return "session_creation_started" }</span>

// SessionCreated is emitted when session creation completes successfully
type SessionCreated struct {
        Session Session `json:"session"`
}

func (e SessionCreated) EventType() string <span class="cov8" title="1">{ return "session_created" }</span>

// SessionCreationFailed is emitted when session creation fails
type SessionCreationFailed struct {
        Name  string `json:"name"`
        Error string `json:"error"`
}

func (e SessionCreationFailed) EventType() string <span class="cov8" title="1">{ return "session_creation_failed" }</span>

// SessionDeleted is emitted when session deletion completes
type SessionDeleted struct {
        SessionID string `json:"session_id"`
}

func (e SessionDeleted) EventType() string <span class="cov8" title="1">{ return "session_deleted" }</span>

// SessionDeletionFailed is emitted when session deletion fails
type SessionDeletionFailed struct {
        SessionID string `json:"session_id"`
        Error     string `json:"error"`
}

func (e SessionDeletionFailed) EventType() string <span class="cov8" title="1">{ return "session_deletion_failed" }</span>

// Periodic Events - triggered by external state changes

// ClaudeStatusChanged is emitted when Claude status changes
type ClaudeStatusChanged struct {
        SessionID string       `json:"session_id"`
        OldStatus ClaudeStatus `json:"old_status"`
        NewStatus ClaudeStatus `json:"new_status"`
}

func (e ClaudeStatusChanged) EventType() string <span class="cov8" title="1">{ return "claude_status_changed" }</span>

// TmuxSessionDied is emitted when a tmux session dies
type TmuxSessionDied struct {
        SessionID   string `json:"session_id"`
        TmuxSession string `json:"tmux_session"`
}

func (e TmuxSessionDied) EventType() string <span class="cov8" title="1">{ return "tmux_session_died" }</span>

// GitChangesDetected is emitted when git changes are detected
type GitChangesDetected struct {
        SessionID string    `json:"session_id"`
        NewStatus GitStatus `json:"new_status"`
}

func (e GitChangesDetected) EventType() string <span class="cov8" title="1">{ return "git_changes_detected" }</span>

// RefreshCompleted is emitted when external state refresh completes
type RefreshCompleted struct {
        Sessions []Session `json:"sessions"`
        Error    string    `json:"error,omitempty"`
}

func (e RefreshCompleted) EventType() string <span class="cov8" title="1">{ return "refresh_completed" }</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// SessionState represents real-time state for a session
// This is updated by hooks and other external events
type SessionState struct {
        SessionID     string                 `json:"session_id"`
        ClaudeState   string                 `json:"claude_state"` // "working", "waiting_for_input", "complete", "idle"
        LastEvent     string                 `json:"last_event"`   // "notification", "stop", "preToolUse", etc.
        LastEventTime time.Time              `json:"last_event_time"`
        LastEventData map[string]interface{} `json:"last_event_data,omitempty"`
        LastMessage   string                 `json:"last_message,omitempty"` // Human-readable message from Claude
        LastUpdated   time.Time              `json:"last_updated"`
}

// LoadSessionState loads session state from the dedicated state file
func LoadSessionState(dataDir, sessionID string) (*SessionState, error) <span class="cov8" title="1">{
        stateFile := filepath.Join(dataDir, "session-state", sessionID+".json")

        data, err := os.ReadFile(stateFile)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, nil // No state file yet
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read session state file: %w", err)</span>
        }

        <span class="cov0" title="0">var state SessionState
        if err := json.Unmarshal(data, &amp;state); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse session state: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;state, nil</span>
}

// SaveSessionState saves session state to the dedicated state file
func SaveSessionState(dataDir string, state *SessionState) error <span class="cov0" title="0">{
        stateDir := filepath.Join(dataDir, "session-state")
        if err := os.MkdirAll(stateDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create session state directory: %w", err)
        }</span>

        <span class="cov0" title="0">stateFile := filepath.Join(stateDir, state.SessionID+".json")

        data, err := json.MarshalIndent(state, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session state: %w", err)
        }</span>

        // Atomic write using temporary file
        <span class="cov0" title="0">tempFile := stateFile + ".tmp"
        if err := os.WriteFile(tempFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temp state file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.Rename(tempFile, stateFile); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempFile) // Cleanup temp file
                return fmt.Errorf("failed to rename temp state file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveSessionState removes the session state file
func RemoveSessionState(dataDir, sessionID string) error <span class="cov8" title="1">{
        stateFile := filepath.Join(dataDir, "session-state", sessionID+".json")
        err := os.Remove(stateFile)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil // Already removed
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ParseClaudeStateFromEvent determines Claude state from hook event data
func ParseClaudeStateFromEvent(eventType string, eventData map[string]interface{}) string <span class="cov0" title="0">{
        switch eventType </span>{
        case "notification":<span class="cov0" title="0">
                // Check if this is a "waiting for input" notification
                if reason, ok := eventData["reason"].(string); ok </span><span class="cov0" title="0">{
                        if reason == "idle" || reason == "waiting_for_permission" </span><span class="cov0" title="0">{
                                return "waiting_for_input"
                        }</span>
                }
                // Check message content for permission requests
                <span class="cov0" title="0">if message, ok := eventData["message"].(string); ok </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(message), "permission") ||
                                strings.Contains(strings.ToLower(message), "needs your") </span><span class="cov0" title="0">{
                                return "waiting_for_input"
                        }</span>
                }
                <span class="cov0" title="0">return "idle"</span>
        case "preToolUse":<span class="cov0" title="0">
                return "working"</span>
        case "postToolUse":<span class="cov0" title="0">
                return "idle"</span>
        case "stop":<span class="cov0" title="0">
                return "complete"</span>
        default:<span class="cov0" title="0">
                return "idle"</span>
        }
}

// GetClaudeStatusFromState converts session state to ClaudeStatus
func GetClaudeStatusFromState(state *SessionState) ClaudeStatus <span class="cov0" title="0">{
        if state == nil </span><span class="cov0" title="0">{
                return ClaudeStatus{
                        State: ClaudeUnknown,
                }
        }</span>

        <span class="cov0" title="0">claudeState := ClaudeUnknown
        switch state.ClaudeState </span>{
        case "working":<span class="cov0" title="0">
                claudeState = ClaudeWorking</span>
        case "waiting_for_input":<span class="cov0" title="0">
                claudeState = ClaudeWaiting</span>
        case "complete":<span class="cov0" title="0">
                claudeState = ClaudeComplete</span>
        case "idle":<span class="cov0" title="0">
                claudeState = ClaudeIdle</span>
        }

        <span class="cov0" title="0">return ClaudeStatus{
                State:         claudeState,
                LastMessage:   state.LastEventTime,
                SessionID:     state.SessionID,
                StatusMessage: state.LastMessage,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
